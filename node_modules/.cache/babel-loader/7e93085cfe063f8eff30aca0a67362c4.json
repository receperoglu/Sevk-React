{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, AutoScroll, classNamesFunction, findScrollableParent, getDistanceBetweenPoints, getRTL, initializeComponentRef } from '../../Utilities';\nvar getClassNames = classNamesFunction(); // We want to make the marquee selection start when the user drags a minimum distance. Otherwise we'd start\n// the drag even if they just click an item without moving.\n\nvar MIN_DRAG_DISTANCE = 5;\n/**\n * MarqueeSelection component abstracts managing a draggable rectangle which sets items selected/not selected.\n * Elements which have data-selectable-index attributes are queried and measured once to determine if they\n * fall within the bounds of the rectangle. The measure is memoized during the drag as a performance optimization\n * so if the items change sizes while dragging, that could cause incorrect results.\n */\n\nvar MarqueeSelectionBase =\n/** @class */\nfunction (_super) {\n  __extends(MarqueeSelectionBase, _super);\n\n  function MarqueeSelectionBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n\n    _this._onMouseDown = function (ev) {\n      var _a = _this.props,\n          isEnabled = _a.isEnabled,\n          onShouldStartSelection = _a.onShouldStartSelection; // Ensure the mousedown is within the boundaries of the target. If not, it may have been a click on a scrollbar.\n\n      if (_this._isMouseEventOnScrollbar(ev)) {\n        return;\n      }\n\n      if (_this._isInSelectionToggle(ev)) {\n        return;\n      }\n\n      if (!_this._isTouch && isEnabled && !_this._isDragStartInSelection(ev) && (!onShouldStartSelection || onShouldStartSelection(ev))) {\n        if (_this._scrollableSurface && ev.button === 0 && _this._root.current) {\n          _this._selectedIndicies = {};\n          _this._preservedIndicies = undefined;\n\n          _this._events.on(window, 'mousemove', _this._onAsyncMouseMove, true);\n\n          _this._events.on(_this._scrollableParent, 'scroll', _this._onAsyncMouseMove);\n\n          _this._events.on(window, 'click', _this._onMouseUp, true);\n\n          _this._autoScroll = new AutoScroll(_this._root.current);\n          _this._scrollTop = _this._scrollableSurface.scrollTop;\n          _this._scrollLeft = _this._scrollableSurface.scrollLeft;\n          _this._rootRect = _this._root.current.getBoundingClientRect();\n\n          _this._onMouseMove(ev);\n        }\n      }\n    };\n\n    _this._onTouchStart = function (ev) {\n      _this._isTouch = true;\n\n      _this._async.setTimeout(function () {\n        _this._isTouch = false;\n      }, 0);\n    };\n\n    _this._onPointerDown = function (ev) {\n      if (ev.pointerType === 'touch') {\n        _this._isTouch = true;\n\n        _this._async.setTimeout(function () {\n          _this._isTouch = false;\n        }, 0);\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this.state = {\n      dragRect: undefined\n    };\n    return _this;\n  }\n\n  MarqueeSelectionBase.prototype.componentDidMount = function () {\n    this._scrollableParent = findScrollableParent(this._root.current);\n    this._scrollableSurface = this._scrollableParent === window ? document.body : this._scrollableParent; // When scroll events come from window, we need to read scrollTop values from the body.\n\n    var hitTarget = this.props.isDraggingConstrainedToRoot ? this._root.current : this._scrollableSurface;\n\n    this._events.on(hitTarget, 'mousedown', this._onMouseDown);\n\n    this._events.on(hitTarget, 'touchstart', this._onTouchStart, true);\n\n    this._events.on(hitTarget, 'pointerdown', this._onPointerDown, true);\n  };\n\n  MarqueeSelectionBase.prototype.componentWillUnmount = function () {\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    delete this._scrollableParent;\n    delete this._scrollableSurface;\n\n    this._events.dispose();\n\n    this._async.dispose();\n  };\n\n  MarqueeSelectionBase.prototype.render = function () {\n    var _a = this.props,\n        rootProps = _a.rootProps,\n        children = _a.children,\n        theme = _a.theme,\n        className = _a.className,\n        styles = _a.styles;\n    var dragRect = this.state.dragRect;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className\n    });\n    return React.createElement(\"div\", __assign({}, rootProps, {\n      className: classNames.root,\n      ref: this._root\n    }), children, dragRect && React.createElement(\"div\", {\n      className: classNames.dragMask\n    }), dragRect && React.createElement(\"div\", {\n      className: classNames.box,\n      style: dragRect\n    }, React.createElement(\"div\", {\n      className: classNames.boxFill\n    })));\n  };\n  /** Determine if the mouse event occured on a scrollbar of the target element. */\n\n\n  MarqueeSelectionBase.prototype._isMouseEventOnScrollbar = function (ev) {\n    var targetElement = ev.target;\n    var targetScrollbarWidth = targetElement.offsetWidth - targetElement.clientWidth;\n\n    if (targetScrollbarWidth) {\n      var targetRect = targetElement.getBoundingClientRect(); // Check vertical scroll\n\n      if (getRTL(this.props.theme)) {\n        if (ev.clientX < targetRect.left + targetScrollbarWidth) {\n          return true;\n        }\n      } else {\n        if (ev.clientX > targetRect.left + targetElement.clientWidth) {\n          return true;\n        }\n      } // Check horizontal scroll\n\n\n      if (ev.clientY > targetRect.top + targetElement.clientHeight) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._getRootRect = function () {\n    return {\n      left: this._rootRect.left + (this._scrollLeft - this._scrollableSurface.scrollLeft),\n      top: this._rootRect.top + (this._scrollTop - this._scrollableSurface.scrollTop),\n      width: this._rootRect.width,\n      height: this._rootRect.height\n    };\n  };\n\n  MarqueeSelectionBase.prototype._onAsyncMouseMove = function (ev) {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      _this._onMouseMove(ev);\n    });\n\n    ev.stopPropagation();\n    ev.preventDefault();\n  };\n\n  MarqueeSelectionBase.prototype._onMouseMove = function (ev) {\n    if (!this._autoScroll) {\n      return;\n    }\n\n    if (ev.clientX !== undefined) {\n      this._lastMouseEvent = ev;\n    }\n\n    var rootRect = this._getRootRect();\n\n    var currentPoint = {\n      left: ev.clientX - rootRect.left,\n      top: ev.clientY - rootRect.top\n    };\n\n    if (!this._dragOrigin) {\n      this._dragOrigin = currentPoint;\n    }\n\n    if (ev.buttons !== undefined && ev.buttons === 0) {\n      this._onMouseUp(ev);\n    } else {\n      if (this.state.dragRect || getDistanceBetweenPoints(this._dragOrigin, currentPoint) > MIN_DRAG_DISTANCE) {\n        if (!this.state.dragRect) {\n          var selection = this.props.selection;\n\n          if (!ev.shiftKey) {\n            selection.setAllSelected(false);\n          }\n\n          this._preservedIndicies = selection && selection.getSelectedIndices && selection.getSelectedIndices();\n        } // We need to constrain the current point to the rootRect boundaries.\n\n\n        var constrainedPoint = this.props.isDraggingConstrainedToRoot ? {\n          left: Math.max(0, Math.min(rootRect.width, this._lastMouseEvent.clientX - rootRect.left)),\n          top: Math.max(0, Math.min(rootRect.height, this._lastMouseEvent.clientY - rootRect.top))\n        } : {\n          left: this._lastMouseEvent.clientX - rootRect.left,\n          top: this._lastMouseEvent.clientY - rootRect.top\n        };\n        var dragRect = {\n          left: Math.min(this._dragOrigin.left || 0, constrainedPoint.left),\n          top: Math.min(this._dragOrigin.top || 0, constrainedPoint.top),\n          width: Math.abs(constrainedPoint.left - (this._dragOrigin.left || 0)),\n          height: Math.abs(constrainedPoint.top - (this._dragOrigin.top || 0))\n        };\n\n        this._evaluateSelection(dragRect, rootRect);\n\n        this.setState({\n          dragRect: dragRect\n        });\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._onMouseUp = function (ev) {\n    this._events.off(window);\n\n    this._events.off(this._scrollableParent, 'scroll');\n\n    if (this._autoScroll) {\n      this._autoScroll.dispose();\n    }\n\n    this._autoScroll = this._dragOrigin = this._lastMouseEvent = undefined;\n    this._selectedIndicies = this._itemRectCache = undefined;\n\n    if (this.state.dragRect) {\n      this.setState({\n        dragRect: undefined\n      });\n      ev.preventDefault();\n      ev.stopPropagation();\n    }\n  };\n\n  MarqueeSelectionBase.prototype._isPointInRectangle = function (rectangle, point) {\n    return !!point.top && rectangle.top < point.top && rectangle.bottom > point.top && !!point.left && rectangle.left < point.left && rectangle.right > point.left;\n  };\n  /**\n   * We do not want to start the marquee if we're trying to marquee\n   * from within an existing marquee selection.\n   */\n\n\n  MarqueeSelectionBase.prototype._isDragStartInSelection = function (ev) {\n    var selection = this.props.selection;\n\n    if (!this._root.current || selection && selection.getSelectedCount() === 0) {\n      return false;\n    }\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = Number(element.getAttribute('data-selection-index'));\n\n      if (selection.isIndexSelected(index)) {\n        var itemRect = element.getBoundingClientRect();\n\n        if (this._isPointInRectangle(itemRect, {\n          left: ev.clientX,\n          top: ev.clientY\n        })) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._isInSelectionToggle = function (ev) {\n    var element = ev.target;\n\n    while (element && element !== this._root.current) {\n      if (element.getAttribute('data-selection-toggle') === 'true') {\n        return true;\n      }\n\n      element = element.parentElement;\n    }\n\n    return false;\n  };\n\n  MarqueeSelectionBase.prototype._evaluateSelection = function (dragRect, rootRect) {\n    // Break early if we don't need to evaluate.\n    if (!dragRect || !this._root.current) {\n      return;\n    }\n\n    var selection = this.props.selection;\n\n    var allElements = this._root.current.querySelectorAll('[data-selection-index]');\n\n    if (!this._itemRectCache) {\n      this._itemRectCache = {};\n    }\n\n    for (var i = 0; i < allElements.length; i++) {\n      var element = allElements[i];\n      var index = element.getAttribute('data-selection-index'); // Pull the memoized rectangle for the item, or the get the rect and memoize.\n\n      var itemRect = this._itemRectCache[index];\n\n      if (!itemRect) {\n        itemRect = element.getBoundingClientRect(); // Normalize the item rect to the dragRect coordinates.\n\n        itemRect = {\n          left: itemRect.left - rootRect.left,\n          top: itemRect.top - rootRect.top,\n          width: itemRect.width,\n          height: itemRect.height,\n          right: itemRect.left - rootRect.left + itemRect.width,\n          bottom: itemRect.top - rootRect.top + itemRect.height\n        };\n\n        if (itemRect.width > 0 && itemRect.height > 0) {\n          this._itemRectCache[index] = itemRect;\n        }\n      }\n\n      if (itemRect.top < dragRect.top + dragRect.height && itemRect.bottom > dragRect.top && itemRect.left < dragRect.left + dragRect.width && itemRect.right > dragRect.left) {\n        this._selectedIndicies[index] = true;\n      } else {\n        delete this._selectedIndicies[index];\n      }\n    } // set previousSelectedIndices to be all of the selected indices from last time\n\n\n    var previousSelectedIndices = this._allSelectedIndices || {};\n    this._allSelectedIndices = {}; // set all indices that are supposed to be selected in _allSelectedIndices\n\n    for (var index in this._selectedIndicies) {\n      if (this._selectedIndicies.hasOwnProperty(index)) {\n        this._allSelectedIndices[index] = true;\n      }\n    }\n\n    if (this._preservedIndicies) {\n      for (var _i = 0, _a = this._preservedIndicies; _i < _a.length; _i++) {\n        var index = _a[_i];\n        this._allSelectedIndices[index] = true;\n      }\n    } // check if needs to update selection, only when current _allSelectedIndices\n    // is different than previousSelectedIndices\n\n\n    var needToUpdate = false;\n\n    for (var index in this._allSelectedIndices) {\n      if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n        needToUpdate = true;\n        break;\n      }\n    }\n\n    if (!needToUpdate) {\n      for (var index in previousSelectedIndices) {\n        if (this._allSelectedIndices[index] !== previousSelectedIndices[index]) {\n          needToUpdate = true;\n          break;\n        }\n      }\n    } // only update selection when needed\n\n\n    if (needToUpdate) {\n      // Stop change events, clear selection to re-populate.\n      selection.setChangeEvents(false);\n      selection.setAllSelected(false);\n\n      for (var _b = 0, _c = Object.keys(this._allSelectedIndices); _b < _c.length; _b++) {\n        var index = _c[_b];\n        selection.setIndexSelected(Number(index), true, false);\n      }\n\n      selection.setChangeEvents(true);\n    }\n  };\n\n  MarqueeSelectionBase.defaultProps = {\n    rootTagName: 'div',\n    rootProps: {},\n    isEnabled: true\n  };\n  return MarqueeSelectionBase;\n}(React.Component);\n\nexport { MarqueeSelectionBase };","map":null,"metadata":{},"sourceType":"module"}