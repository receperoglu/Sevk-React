{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, KeyCodes, css, elementContains, getId, classNamesFunction, styled, initializeComponentRef } from '../../Utilities';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Callout, DirectionalHint } from '../../Callout';\nimport { Selection, SelectionZone, SelectionMode } from '../../utilities/selection/index';\nimport { Suggestions } from './Suggestions/Suggestions';\nimport { getStyles as suggestionsStyles } from './Suggestions/Suggestions.styles';\nimport { SuggestionsController } from './Suggestions/SuggestionsController';\nimport { ValidationState } from './BasePicker.types';\nimport { Autofill } from '../Autofill/index';\nimport * as stylesImport from './BasePicker.scss';\nvar legacyStyles = stylesImport;\nvar getClassNames = classNamesFunction();\n/**\n * Should be removed once new picker without inheritance is created\n */\n\nfunction getStyledSuggestions(suggestionsType) {\n  return styled(suggestionsType, suggestionsStyles, undefined, {\n    scope: 'Suggestions'\n  });\n}\n/**\n * {@docCategory Pickers}\n */\n\n\nvar BasePicker =\n/** @class */\nfunction (_super) {\n  __extends(BasePicker, _super);\n\n  function BasePicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this; // Refs\n\n\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n    _this.focusZone = React.createRef();\n    _this.suggestionElement = React.createRef();\n    /**\n     * @deprecated this is no longer necessary as typescript now supports generic elements\n     */\n\n    _this.SuggestionOfProperType = Suggestions; // eslint-disable-next-line deprecation/deprecation\n\n    _this._styledSuggestions = getStyledSuggestions(_this.SuggestionOfProperType);\n\n    _this.dismissSuggestions = function (ev) {\n      var selectItemFunction = function selectItemFunction() {\n        var addItemOnDismiss = true;\n\n        if (_this.props.onDismiss) {\n          addItemOnDismiss = _this.props.onDismiss(ev, _this.suggestionStore.currentSuggestion ? _this.suggestionStore.currentSuggestion.item : undefined);\n        }\n\n        if (!ev || ev && !ev.defaultPrevented) {\n          // Select the first suggestion if one is available and permitted by onDismiss when user leaves.\n          if (addItemOnDismiss !== false && _this.canAddItems() && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestedDisplayValue) {\n            _this.addItemByIndex(0);\n          }\n        }\n      };\n\n      if (_this.currentPromise) {\n        _this.currentPromise.then(function () {\n          return selectItemFunction();\n        });\n      } else {\n        selectItemFunction();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.refocusSuggestions = function (keyCode) {\n      _this.resetFocus();\n\n      if (_this.suggestionStore.suggestions && _this.suggestionStore.suggestions.length > 0) {\n        if (keyCode === KeyCodes.up) {\n          _this.suggestionStore.setSelectedSuggestion(_this.suggestionStore.suggestions.length - 1);\n        } else if (keyCode === KeyCodes.down) {\n          _this.suggestionStore.setSelectedSuggestion(0);\n        }\n      }\n    };\n\n    _this.onInputChange = function (value) {\n      _this.updateValue(value);\n\n      _this.setState({\n        moreSuggestionsAvailable: true,\n        isMostRecentlyUsedVisible: false\n      });\n    };\n\n    _this.onSuggestionClick = function (ev, item, index) {\n      _this.addItemByIndex(index);\n    };\n\n    _this.onSuggestionRemove = function (ev, item, index) {\n      if (_this.props.onRemoveSuggestion) {\n        _this.props.onRemoveSuggestion(item);\n      }\n\n      _this.suggestionStore.removeSuggestion(index);\n    };\n\n    _this.onInputFocus = function (ev) {\n      _this.selection.setAllSelected(false); // Only trigger all of the focus if this component isn't already focused.\n      // For example when an item is selected or removed from the selected list it should be treated\n      // as though the input is still focused.\n\n\n      if (!_this.state.isFocused) {\n        _this.setState({\n          isFocused: true\n        });\n\n        _this._userTriggeredSuggestions();\n\n        if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n          _this.props.inputProps.onFocus(ev);\n        }\n      }\n    };\n\n    _this.onInputBlur = function (ev) {\n      if (_this.props.inputProps && _this.props.inputProps.onBlur) {\n        _this.props.inputProps.onBlur(ev);\n      }\n    };\n\n    _this.onBlur = function (ev) {\n      if (_this.state.isFocused) {\n        // Only blur the entire component if an unrelated element gets focus.\n        // Otherwise treat it as though it still has focus.\n        // Do nothing if the blur is coming from something\n        // inside the comboBox root or the comboBox menu since\n        // it we are not really bluring from the whole comboBox\n        var relatedTarget = ev.relatedTarget;\n\n        if (ev.relatedTarget === null) {\n          // In IE11, due to lack of support, event.relatedTarget is always\n          // null making every onBlur call to be \"outside\" of the ComboBox\n          // even when it's not. Using document.activeElement is another way\n          // for us to be able to get what the relatedTarget without relying\n          // on the event\n          relatedTarget = document.activeElement;\n        }\n\n        if (relatedTarget && !elementContains(_this.root.current, relatedTarget)) {\n          _this.setState({\n            isFocused: false\n          });\n\n          if (_this.props.onBlur) {\n            _this.props.onBlur(ev);\n          }\n        }\n      }\n    };\n    /**\n     * Reveals suggestions any time the user clicks on the input element\n     * without shifting focus.\n     */\n\n\n    _this.onClick = function (ev) {\n      if (_this.props.inputProps !== undefined && _this.props.inputProps.onClick !== undefined) {\n        _this.props.inputProps.onClick(ev);\n      } // Only primary (left) clicks show suggestions.\n\n\n      if (ev.button === 0) {\n        _this._userTriggeredSuggestions();\n      }\n    };\n\n    _this.onKeyDown = function (ev) {\n      var keyCode = ev.which;\n\n      switch (keyCode) {\n        case KeyCodes.escape:\n          if (_this.state.suggestionsVisible) {\n            _this.setState({\n              suggestionsVisible: false\n            });\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          }\n\n          break;\n\n        case KeyCodes.tab:\n        case KeyCodes.enter:\n          if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedActionSelected()) {\n            _this.suggestionElement.current.executeSelectedAction();\n          } else if (!ev.shiftKey && _this.suggestionStore.hasSelectedSuggestion() && _this.state.suggestionsVisible) {\n            _this.completeSuggestion();\n\n            ev.preventDefault();\n            ev.stopPropagation();\n          } else {\n            _this._completeGenericSuggestion();\n          }\n\n          break;\n\n        case KeyCodes.backspace:\n          if (!_this.props.disabled) {\n            _this.onBackspace(ev);\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.del:\n          if (!_this.props.disabled) {\n            if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible && _this.suggestionStore.currentIndex !== -1) {\n              if (_this.props.onRemoveSuggestion) {\n                _this.props.onRemoveSuggestion(_this.suggestionStore.currentSuggestion.item);\n              }\n\n              _this.suggestionStore.removeSuggestion(_this.suggestionStore.currentIndex);\n\n              _this.forceUpdate();\n            } else {\n              _this.onBackspace(ev);\n            }\n          }\n\n          ev.stopPropagation();\n          break;\n\n        case KeyCodes.up:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex === 0) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusAboveSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.previousSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n\n        case KeyCodes.down:\n          if (_this.input.current && ev.target === _this.input.current.inputElement && _this.state.suggestionsVisible) {\n            if (_this.suggestionElement.current && _this.suggestionElement.current.tryHandleKeyDown(keyCode, _this.suggestionStore.currentIndex)) {\n              ev.preventDefault();\n              ev.stopPropagation();\n\n              _this.forceUpdate();\n            } else {\n              if (_this.suggestionElement.current && _this.suggestionElement.current.hasSuggestedAction() && _this.suggestionStore.currentIndex + 1 === _this.suggestionStore.suggestions.length) {\n                ev.preventDefault();\n                ev.stopPropagation();\n\n                _this.suggestionElement.current.focusBelowSuggestions();\n\n                _this.suggestionStore.deselectAllSuggestions();\n\n                _this.forceUpdate();\n              } else {\n                if (_this.suggestionStore.nextSuggestion()) {\n                  ev.preventDefault();\n                  ev.stopPropagation();\n\n                  _this.onSuggestionSelect();\n                }\n              }\n            }\n          }\n\n          break;\n      }\n    };\n\n    _this.onItemChange = function (changedItem, index) {\n      var items = _this.state.items;\n\n      if (index >= 0) {\n        var newItems = items;\n        newItems[index] = changedItem;\n\n        _this._updateSelectedItems(newItems);\n      }\n    };\n\n    _this.onGetMoreResults = function () {\n      _this.setState({\n        isSearching: true\n      }, function () {\n        if (_this.props.onGetMoreResults && _this.input.current) {\n          var suggestions = _this.props.onGetMoreResults(_this.input.current.value, _this.state.items);\n\n          var suggestionsArray = suggestions;\n          var suggestionsPromiseLike = suggestions;\n\n          if (Array.isArray(suggestionsArray)) {\n            _this.updateSuggestions(suggestionsArray);\n\n            _this.setState({\n              isSearching: false\n            });\n          } else if (suggestionsPromiseLike.then) {\n            suggestionsPromiseLike.then(function (newSuggestions) {\n              _this.updateSuggestions(newSuggestions);\n\n              _this.setState({\n                isSearching: false\n              });\n            });\n          }\n        } else {\n          _this.setState({\n            isSearching: false\n          });\n        }\n\n        if (_this.input.current) {\n          _this.input.current.focus();\n        }\n\n        _this.setState({\n          moreSuggestionsAvailable: false,\n          isResultsFooterVisible: true\n        });\n      });\n    };\n\n    _this.completeSelection = function (item) {\n      _this.addItem(item);\n\n      _this.updateValue('');\n\n      if (_this.input.current) {\n        _this.input.current.clear();\n      }\n\n      _this.setState({\n        suggestionsVisible: false\n      });\n    };\n\n    _this.addItemByIndex = function (index) {\n      _this.completeSelection(_this.suggestionStore.getSuggestionAtIndex(index).item);\n    };\n\n    _this.addItem = function (item) {\n      var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n\n      if (processedItem === null) {\n        return;\n      }\n\n      var processedItemObject = processedItem;\n      var processedItemPromiseLike = processedItem;\n\n      if (processedItemPromiseLike && processedItemPromiseLike.then) {\n        processedItemPromiseLike.then(function (resolvedProcessedItem) {\n          var newItems = _this.state.items.concat([resolvedProcessedItem]);\n\n          _this._updateSelectedItems(newItems);\n        });\n      } else {\n        var newItems = _this.state.items.concat([processedItemObject]);\n\n        _this._updateSelectedItems(newItems);\n      }\n\n      _this.setState({\n        suggestedDisplayValue: ''\n      });\n    };\n\n    _this.removeItem = function (item, focusNextItem) {\n      var items = _this.state.items;\n      var index = items.indexOf(item);\n\n      if (index >= 0) {\n        var newItems = items.slice(0, index).concat(items.slice(index + 1));\n\n        _this._updateSelectedItems(newItems);\n      }\n    };\n\n    _this.removeItems = function (itemsToRemove) {\n      var items = _this.state.items;\n      var newItems = items.filter(function (item) {\n        return itemsToRemove.indexOf(item) === -1;\n      });\n\n      _this._updateSelectedItems(newItems);\n    };\n\n    _this._shouldFocusZoneEnterInnerZone = function (ev) {\n      // If suggestions are shown const up/down keys control them, otherwise allow them through to control the focusZone.\n      if (_this.state.suggestionsVisible) {\n        switch (ev.which) {\n          case KeyCodes.up:\n          case KeyCodes.down:\n            return true;\n        }\n      }\n\n      if (ev.which === KeyCodes.enter) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this._onResolveSuggestions = function (updatedValue) {\n      var suggestions = _this.props.onResolveSuggestions(updatedValue, _this.state.items);\n\n      if (suggestions !== null) {\n        _this.updateSuggestionsList(suggestions, updatedValue);\n      }\n    };\n\n    _this._completeGenericSuggestion = function () {\n      if (_this.props.onValidateInput && _this.input.current && _this.props.onValidateInput(_this.input.current.value) !== ValidationState.invalid && _this.props.createGenericItem) {\n        var itemToConvert = _this.props.createGenericItem(_this.input.current.value, _this.props.onValidateInput(_this.input.current.value));\n\n        _this.suggestionStore.createGenericSuggestion(itemToConvert);\n\n        _this.completeSuggestion();\n      }\n    };\n    /**\n     * This should be called when the user does something other than use text entry to trigger suggestions.\n     *\n     */\n\n\n    _this._userTriggeredSuggestions = function () {\n      if (!_this.state.suggestionsVisible) {\n        var input = _this.input.current ? _this.input.current.value : '';\n\n        if (!input) {\n          _this.onEmptyInputFocus();\n        } else {\n          if (_this.suggestionStore.suggestions.length === 0) {\n            _this._onResolveSuggestions(input);\n          } else {\n            _this.setState({\n              isMostRecentlyUsedVisible: false,\n              suggestionsVisible: true\n            });\n          }\n        }\n      }\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    var items = basePickerProps.selectedItems || basePickerProps.defaultSelectedItems || [];\n    _this._id = getId();\n    _this._ariaMap = {\n      selectedItems: \"selected-items-\" + _this._id,\n      selectedSuggestionAlert: \"selected-suggestion-alert-\" + _this._id,\n      suggestionList: \"suggestion-list-\" + _this._id,\n      combobox: \"combobox-\" + _this._id\n    };\n    _this.suggestionStore = new SuggestionsController();\n    _this.selection = new Selection({\n      onSelectionChanged: function onSelectionChanged() {\n        return _this.onSelectionChange();\n      }\n    });\n\n    _this.selection.setItems(items);\n\n    _this.state = {\n      items: items,\n      suggestedDisplayValue: '',\n      isMostRecentlyUsedVisible: false,\n      moreSuggestionsAvailable: false,\n      isFocused: false,\n      isSearching: false,\n      selectedIndices: []\n    };\n    return _this;\n  }\n\n  BasePicker.getDerivedStateFromProps = function (newProps) {\n    if (newProps.selectedItems) {\n      return {\n        items: newProps.selectedItems\n      };\n    }\n\n    return null;\n  };\n\n  Object.defineProperty(BasePicker.prototype, \"items\", {\n    get: function get() {\n      return this.state.items;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BasePicker.prototype.componentDidMount = function () {\n    this.selection.setItems(this.state.items);\n    this._onResolveSuggestions = this._async.debounce(this._onResolveSuggestions, this.props.resolveDelay);\n  };\n\n  BasePicker.prototype.componentDidUpdate = function (oldProps, oldState) {\n    if (this.state.items && this.state.items !== oldState.items) {\n      var currentSelectedIndex = this.selection.getSelectedIndices()[0];\n      this.selection.setItems(this.state.items);\n\n      if (this.state.isFocused) {\n        // Reset focus and selection so that selected item stays in sync if something\n        // has been removed\n        if (this.state.items.length < oldState.items.length) {\n          this.selection.setIndexSelected(currentSelectedIndex, true, true);\n          this.resetFocus(currentSelectedIndex);\n        }\n      }\n    }\n  };\n\n  BasePicker.prototype.componentWillUnmount = function () {\n    if (this.currentPromise) {\n      this.currentPromise = undefined;\n    }\n\n    this._async.dispose();\n  };\n\n  BasePicker.prototype.focus = function () {\n    if (this.focusZone.current) {\n      this.focusZone.current.focus();\n    }\n  };\n\n  BasePicker.prototype.focusInput = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n\n  BasePicker.prototype.completeSuggestion = function (forceComplete) {\n    if (this.suggestionStore.hasSelectedSuggestion() && this.input.current) {\n      this.completeSelection(this.suggestionStore.currentSuggestion.item);\n    } else if (forceComplete) {\n      this._completeGenericSuggestion();\n    }\n  };\n\n  BasePicker.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused,\n        items = _a.items;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        theme = _b.theme,\n        styles = _b.styles;\n    var selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert ? this._ariaMap.selectedSuggestionAlert : '';\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : ''; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      disabled: disabled,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      itemsWrapper: legacyStyles.pickerItems,\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: classNames.root,\n      onKeyDown: this.onKeyDown,\n      onBlur: this.onBlur\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone,\n      role: 'combobox',\n      id: this._ariaMap.combobox,\n      \"aria-label\": this.props['aria-label'],\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-owns\": suggestionsAvailable || undefined,\n      \"aria-haspopup\": suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog'\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: classNames.text\n    }, items.length > 0 && React.createElement(\"span\", {\n      id: this._ariaMap.selectedItems,\n      className: classNames.itemsWrapper,\n      role: 'list'\n    }, this.renderItems()), this.canAddItems() && React.createElement(Autofill, __assign({\n      spellCheck: false\n    }, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onClick: this.onClick,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"arial-labelledby\": this.props['aria-label'] ? this._ariaMap.combobox : undefined,\n      \"aria-describedby\": items.length > 0 ? this._ariaMap.selectedItems : undefined,\n      \"aria-controls\": suggestionsAvailable + \" \" + selectedSuggestionAlertId || undefined,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      role: 'textbox',\n      disabled: disabled,\n      onInputChange: this.props.onInputChange\n    }))))), this.renderSuggestions());\n  };\n\n  BasePicker.prototype.canAddItems = function () {\n    var items = this.state.items;\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || items.length < itemLimit;\n  };\n\n  BasePicker.prototype.renderSuggestions = function () {\n    var StyledTypedSuggestions = this._styledSuggestions;\n    return this.state.suggestionsVisible && this.input ? React.createElement(Callout, __assign({\n      isBeakVisible: false,\n      gapSpace: 5,\n      target: this.input.current ? this.input.current.inputElement : undefined,\n      onDismiss: this.dismissSuggestions,\n      directionalHint: DirectionalHint.bottomLeftEdge,\n      directionalHintForRTL: DirectionalHint.bottomRightEdge\n    }, this.props.pickerCalloutProps), React.createElement(StyledTypedSuggestions // Assumed to set in derived component's defaultProps\n    , __assign({\n      // Assumed to set in derived component's defaultProps\n      onRenderSuggestion: this.props.onRenderSuggestionsItem,\n      onSuggestionClick: this.onSuggestionClick,\n      onSuggestionRemove: this.onSuggestionRemove,\n      suggestions: this.suggestionStore.getSuggestions(),\n      componentRef: this.suggestionElement,\n      onGetMoreResults: this.onGetMoreResults,\n      moreSuggestionsAvailable: this.state.moreSuggestionsAvailable,\n      isLoading: this.state.suggestionsLoading,\n      isSearching: this.state.isSearching,\n      isMostRecentlyUsedVisible: this.state.isMostRecentlyUsedVisible,\n      isResultsFooterVisible: this.state.isResultsFooterVisible,\n      refocusSuggestions: this.refocusSuggestions,\n      removeSuggestionAriaLabel: this.props.removeButtonAriaLabel,\n      suggestionsListId: this._ariaMap.suggestionList,\n      createGenericItem: this._completeGenericSuggestion\n    }, this.props.pickerSuggestionsProps))) : null;\n  };\n\n  BasePicker.prototype.renderItems = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        removeButtonAriaLabel = _a.removeButtonAriaLabel;\n    var onRenderItem = this.props.onRenderItem;\n    var _b = this.state,\n        items = _b.items,\n        selectedIndices = _b.selectedIndices;\n    return items.map(function (item, index) {\n      return onRenderItem({\n        item: item,\n        index: index,\n        key: item.key ? item.key : index,\n        selected: selectedIndices.indexOf(index) !== -1,\n        onRemoveItem: function onRemoveItem() {\n          return _this.removeItem(item, true);\n        },\n        disabled: disabled,\n        onItemChange: _this.onItemChange,\n        removeButtonAriaLabel: removeButtonAriaLabel\n      });\n    });\n  };\n\n  BasePicker.prototype.resetFocus = function (index) {\n    var items = this.state.items;\n\n    if (items.length && index >= 0) {\n      var newEl = this.root.current && this.root.current.querySelectorAll('[data-selection-index]')[Math.min(index, items.length - 1)];\n\n      if (newEl && this.focusZone.current) {\n        this.focusZone.current.focusElement(newEl);\n      }\n    } else if (!this.canAddItems()) {\n      this.resetFocus(items.length - 1);\n    } else {\n      if (this.input.current) {\n        this.input.current.focus();\n      }\n    }\n  };\n\n  BasePicker.prototype.onSuggestionSelect = function () {\n    if (this.suggestionStore.currentSuggestion) {\n      var currentValue = this.input.current ? this.input.current.value : '';\n\n      var itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, currentValue);\n\n      this.setState({\n        suggestedDisplayValue: itemValue\n      });\n    }\n  };\n\n  BasePicker.prototype.onSelectionChange = function () {\n    this.setState({\n      selectedIndices: this.selection.getSelectedIndices()\n    });\n  };\n\n  BasePicker.prototype.updateSuggestions = function (suggestions) {\n    this.suggestionStore.updateSuggestions(suggestions, 0);\n    this.forceUpdate();\n  };\n  /**\n   * Only to be called when there is nothing in the input. Checks to see if the consumer has\n   * provided a function to resolve suggestions\n   */\n\n\n  BasePicker.prototype.onEmptyInputFocus = function () {\n    var emptyResolveSuggestions = this.props.onEmptyResolveSuggestions ? this.props.onEmptyResolveSuggestions : // eslint-disable-next-line deprecation/deprecation\n    this.props.onEmptyInputFocus; // Only attempt to resolve suggestions if it exists\n\n    if (emptyResolveSuggestions) {\n      var suggestions = emptyResolveSuggestions(this.state.items);\n      this.updateSuggestionsList(suggestions);\n      this.setState({\n        isMostRecentlyUsedVisible: true,\n        suggestionsVisible: true,\n        moreSuggestionsAvailable: false\n      });\n    }\n  };\n\n  BasePicker.prototype.updateValue = function (updatedValue) {\n    this._onResolveSuggestions(updatedValue);\n  };\n\n  BasePicker.prototype.updateSuggestionsList = function (suggestions, updatedValue) {\n    var _this = this;\n\n    var suggestionsArray = suggestions;\n    var suggestionsPromiseLike = suggestions; // Check to see if the returned value is an array, if it is then just pass it into the next function .\n    // If the returned value is not an array then check to see if it's a promise or PromiseLike.\n    // If it is then resolve it asynchronously.\n\n    if (Array.isArray(suggestionsArray)) {\n      this._updateAndResolveValue(updatedValue, suggestionsArray);\n    } else if (suggestionsPromiseLike && suggestionsPromiseLike.then) {\n      this.setState({\n        suggestionsLoading: true\n      }); // Clear suggestions\n\n      this.suggestionStore.updateSuggestions([]);\n\n      if (updatedValue !== undefined) {\n        this.setState({\n          suggestionsVisible: this._getShowSuggestions()\n        });\n      } else {\n        this.setState({\n          suggestionsVisible: this.input.current && this.input.current.inputElement === document.activeElement\n        });\n      } // Ensure that the promise will only use the callback if it was the most recent one.\n\n\n      var promise_1 = this.currentPromise = suggestionsPromiseLike;\n      promise_1.then(function (newSuggestions) {\n        if (promise_1 === _this.currentPromise) {\n          _this._updateAndResolveValue(updatedValue, newSuggestions);\n        }\n      });\n    }\n  };\n\n  BasePicker.prototype.resolveNewValue = function (updatedValue, suggestions) {\n    var _this = this;\n\n    this.updateSuggestions(suggestions);\n    var itemValue = undefined;\n\n    if (this.suggestionStore.currentSuggestion) {\n      itemValue = this._getTextFromItem(this.suggestionStore.currentSuggestion.item, updatedValue);\n    } // Only set suggestionloading to false after there has been time for the new suggestions to flow\n    // to the suggestions list. This is to ensure that the suggestions are available before aria-activedescendant\n    // is set so that screen readers will read out the first selected option.\n\n\n    this.setState({\n      suggestedDisplayValue: itemValue,\n      suggestionsVisible: this._getShowSuggestions()\n    }, function () {\n      return _this.setState({\n        suggestionsLoading: false\n      });\n    });\n  };\n\n  BasePicker.prototype.onChange = function (items) {\n    if (this.props.onChange) {\n      this.props.onChange(items);\n    }\n  }; // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n  // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n\n\n  BasePicker.prototype.onBackspace = function (ev) {\n    if (this.state.items.length && !this.input.current || this.input.current && !this.input.current.isValueSelected && this.input.current.cursorLocation === 0) {\n      if (this.selection.getSelectedCount() > 0) {\n        this.removeItems(this.selection.getSelection());\n      } else {\n        this.removeItem(this.state.items[this.state.items.length - 1]);\n      }\n    }\n  };\n\n  BasePicker.prototype.getActiveDescendant = function () {\n    if (this.state.suggestionsLoading) {\n      return undefined;\n    }\n\n    var currentIndex = this.suggestionStore.currentIndex; // if the suggestions element has actions and the currentIndex does not point to a suggestion, return the action id\n\n    if (currentIndex < 0 && this.suggestionElement.current && this.suggestionElement.current.hasSuggestedAction()) {\n      return 'sug-selectedAction';\n    }\n\n    return currentIndex > -1 && !this.state.suggestionsLoading ? 'sug-' + currentIndex : undefined;\n  };\n\n  BasePicker.prototype.getSuggestionsAlert = function (suggestionAlertClassName) {\n    if (suggestionAlertClassName === void 0) {\n      suggestionAlertClassName = legacyStyles.screenReaderOnly;\n    }\n\n    var currentIndex = this.suggestionStore.currentIndex;\n\n    if (this.props.enableSelectedSuggestionAlert) {\n      var selectedSuggestion = currentIndex > -1 ? this.suggestionStore.getSuggestionAtIndex(this.suggestionStore.currentIndex) : undefined;\n      var selectedSuggestionAlertText = selectedSuggestion ? selectedSuggestion.ariaLabel : undefined;\n      return React.createElement(\"div\", {\n        className: suggestionAlertClassName,\n        role: \"alert\",\n        id: this._ariaMap.selectedSuggestionAlert,\n        \"aria-live\": \"assertive\"\n      }, selectedSuggestionAlertText, ' ');\n    }\n  };\n  /**\n   * Takes in the current updated value and either resolves it with the new suggestions\n   * or if updated value is undefined then it clears out currently suggested items\n   */\n\n\n  BasePicker.prototype._updateAndResolveValue = function (updatedValue, newSuggestions) {\n    if (updatedValue !== undefined) {\n      this.resolveNewValue(updatedValue, newSuggestions);\n    } else {\n      this.suggestionStore.updateSuggestions(newSuggestions, -1);\n\n      if (this.state.suggestionsLoading) {\n        this.setState({\n          suggestionsLoading: false\n        });\n      }\n    }\n  };\n  /**\n   * Controls what happens whenever there is an action that impacts the selected items.\n   * If `selectedItems` is provided, this will act as a controlled component and it will not update its own state.\n   */\n\n\n  BasePicker.prototype._updateSelectedItems = function (items) {\n    var _this = this;\n\n    if (this.props.selectedItems) {\n      // If the component is a controlled component then the controlling component will need to add or remove the items.\n      this.onChange(items);\n    } else {\n      this.setState({\n        items: items\n      }, function () {\n        _this._onSelectedItemsUpdated(items);\n      });\n    }\n  };\n\n  BasePicker.prototype._onSelectedItemsUpdated = function (items) {\n    this.onChange(items);\n  };\n  /**\n   * Suggestions are normally shown after the user updates text and the text\n   * is non-empty, but also when the user clicks on the input element.\n   * @returns True if suggestions should be shown.\n   */\n\n\n  BasePicker.prototype._getShowSuggestions = function () {\n    var areSuggestionsVisible = this.input.current !== undefined && this.input.current !== null && this.input.current.inputElement === document.activeElement && this.input.current.value !== '';\n    return areSuggestionsVisible;\n  };\n\n  BasePicker.prototype._getTextFromItem = function (item, currentValue) {\n    if (this.props.getTextFromItem) {\n      return this.props.getTextFromItem(item, currentValue);\n    } else {\n      return '';\n    }\n  };\n\n  return BasePicker;\n}(React.Component);\n\nexport { BasePicker };\n\nvar BasePickerListBelow =\n/** @class */\nfunction (_super) {\n  __extends(BasePickerListBelow, _super);\n\n  function BasePickerListBelow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  BasePickerListBelow.prototype.render = function () {\n    var _a = this.state,\n        suggestedDisplayValue = _a.suggestedDisplayValue,\n        isFocused = _a.isFocused;\n    var _b = this.props,\n        className = _b.className,\n        inputProps = _b.inputProps,\n        disabled = _b.disabled,\n        theme = _b.theme,\n        styles = _b.styles;\n    var selectedSuggestionAlertId = this.props.enableSelectedSuggestionAlert ? this._ariaMap.selectedSuggestionAlert : '';\n    var suggestionsAvailable = this.state.suggestionsVisible ? this._ariaMap.suggestionList : ''; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from BasePicker class because it\n    // might be used by consumers who created custom pickers from extending from\n    // this base class and have not used the new 'styles' prop.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // for every other already existing picker variant (PeoplePicker, TagPicker)\n    // so that we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    var classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      isFocused: isFocused,\n      inputClassName: inputProps && inputProps.className\n    }) : {\n      root: css('ms-BasePicker', className ? className : ''),\n      text: css('ms-BasePicker-text', legacyStyles.pickerText, this.state.isFocused && legacyStyles.inputFocused),\n      input: css('ms-BasePicker-input', legacyStyles.pickerInput, inputProps && inputProps.className),\n      screenReaderText: legacyStyles.screenReaderOnly\n    };\n    return React.createElement(\"div\", {\n      ref: this.root,\n      onBlur: this.onBlur\n    }, React.createElement(\"div\", {\n      className: classNames.root,\n      onKeyDown: this.onKeyDown\n    }, this.getSuggestionsAlert(classNames.screenReaderText), React.createElement(\"div\", {\n      className: classNames.text,\n      \"aria-owns\": suggestionsAvailable || undefined,\n      \"aria-expanded\": !!this.state.suggestionsVisible,\n      \"aria-haspopup\": suggestionsAvailable && this.suggestionStore.suggestions.length > 0 ? 'listbox' : 'dialog',\n      role: \"combobox\"\n    }, React.createElement(Autofill, __assign({}, inputProps, {\n      className: classNames.input,\n      componentRef: this.input,\n      onFocus: this.onInputFocus,\n      onBlur: this.onInputBlur,\n      onClick: this.onClick,\n      onInputValueChange: this.onInputChange,\n      suggestedDisplayValue: suggestedDisplayValue,\n      \"aria-activedescendant\": this.getActiveDescendant(),\n      role: \"textbox\",\n      disabled: disabled,\n      \"aria-controls\": suggestionsAvailable + \" \" + selectedSuggestionAlertId || undefined,\n      onInputChange: this.props.onInputChange\n    })))), this.renderSuggestions(), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.single\n    }, React.createElement(FocusZone, {\n      componentRef: this.focusZone,\n      className: \"ms-BasePicker-selectedItems\" // just a className hook without any styles applied to it.\n      ,\n      isCircularNavigation: true,\n      direction: FocusZoneDirection.bidirectional,\n      shouldEnterInnerZone: this._shouldFocusZoneEnterInnerZone,\n      id: this._ariaMap.selectedItems,\n      role: 'list'\n    }, this.renderItems())));\n  };\n\n  BasePickerListBelow.prototype.onBackspace = function (ev) {// override the existing backspace method to not do anything because the list items appear below.\n  };\n\n  return BasePickerListBelow;\n}(BasePicker);\n\nexport { BasePickerListBelow };","map":null,"metadata":{},"sourceType":"module"}