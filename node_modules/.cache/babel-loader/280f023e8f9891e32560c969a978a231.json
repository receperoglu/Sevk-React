{"ast":null,"code":"var _a;\n\nimport { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { getClassNames } from './PositioningContainer.styles';\nimport { Layer } from '../../../Layer'; // Utilites/Helpers\n\nimport { DirectionalHint } from '../../../common/DirectionalHint';\nimport { css, elementContains, focusFirstChild, getWindow, getDocument, initializeComponentRef, Async, EventGroup } from '../../../Utilities';\nimport { getMaxHeight, positionElement, RectangleEdge } from '../../../utilities/positioning';\nimport { AnimationClassNames, mergeStyles } from '../../../Styling';\nvar OFF_SCREEN_STYLE = {\n  opacity: 0\n}; // In order for some of the max height logic to work\n// properly we need to set the border.\n// The value is abitrary.\n\nvar BORDER_WIDTH = 1;\nvar SLIDE_ANIMATIONS = (_a = {}, _a[RectangleEdge.top] = 'slideUpIn20', _a[RectangleEdge.bottom] = 'slideDownIn20', _a[RectangleEdge.left] = 'slideLeftIn20', _a[RectangleEdge.right] = 'slideRightIn20', _a);\n\nvar PositioningContainer =\n/** @class */\nfunction (_super) {\n  __extends(PositioningContainer, _super);\n\n  function PositioningContainer(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The primary positioned div.\n     */\n\n\n    _this._positionedHost = React.createRef(); // @TODO rename to reflect the name of this class\n\n    _this._contentHost = React.createRef();\n    /**\n     * Deprecated, use `onResize` instead.\n     * @deprecated Use `onResize` instead.\n     */\n\n    _this.dismiss = function (ev) {\n      _this.onResize(ev);\n    };\n\n    _this.onResize = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      } else {\n        _this._updateAsyncPosition();\n      }\n    };\n\n    _this._setInitialFocus = function () {\n      if (_this._contentHost.current && _this.props.setInitialFocus && !_this._didSetInitialFocus && _this.state.positions) {\n        _this._didSetInitialFocus = true;\n        focusFirstChild(_this._contentHost.current);\n      }\n    };\n\n    _this._onComponentDidMount = function () {\n      // This is added so the positioningContainer will dismiss when the window is scrolled\n      // but not when something inside the positioningContainer is scrolled. The delay seems\n      // to be required to avoid React firing an async focus event in IE from\n      // the target changing focus quickly prior to rendering the positioningContainer.\n      _this._async.setTimeout(function () {\n        _this._events.on(_this._targetWindow, 'scroll', _this._async.throttle(_this._dismissOnScroll, 10), true);\n\n        _this._events.on(_this._targetWindow, 'resize', _this._async.throttle(_this.onResize, 10), true);\n\n        _this._events.on(_this._targetWindow.document.body, 'focus', _this._dismissOnLostFocus, true);\n\n        _this._events.on(_this._targetWindow.document.body, 'click', _this._dismissOnLostFocus, true);\n      }, 0);\n\n      if (_this.props.onLayerMounted) {\n        _this.props.onLayerMounted();\n      }\n\n      _this._updateAsyncPosition();\n\n      _this._setHeightOffsetEveryFrame();\n    };\n\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._didSetInitialFocus = false;\n    _this.state = {\n      positions: undefined,\n      heightOffset: 0\n    };\n    _this._positionAttempts = 0;\n    return _this;\n  }\n\n  PositioningContainer.prototype.UNSAFE_componentWillMount = function () {\n    this._setTargetWindowAndElement(this._getTarget());\n  };\n\n  PositioningContainer.prototype.componentDidMount = function () {\n    this._onComponentDidMount();\n  };\n\n  PositioningContainer.prototype.componentDidUpdate = function () {\n    this._setInitialFocus();\n\n    this._updateAsyncPosition();\n  };\n\n  PositioningContainer.prototype.UNSAFE_componentWillUpdate = function (newProps) {\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    var newTarget = this._getTarget(newProps);\n\n    var oldTarget = this._getTarget();\n\n    if (newTarget !== oldTarget || typeof newTarget === 'string' || newTarget instanceof String) {\n      this._maxHeight = undefined;\n\n      this._setTargetWindowAndElement(newTarget);\n    }\n\n    if (newProps.offsetFromTarget !== this.props.offsetFromTarget) {\n      this._maxHeight = undefined;\n    }\n\n    if (newProps.finalHeight !== this.props.finalHeight) {\n      this._setHeightOffsetEveryFrame();\n    }\n  };\n\n  PositioningContainer.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  PositioningContainer.prototype.render = function () {\n    // If there is no target window then we are likely in server side rendering and we should not render anything.\n    if (!this._targetWindow) {\n      return null;\n    }\n\n    var _a = this.props,\n        className = _a.className,\n        positioningContainerWidth = _a.positioningContainerWidth,\n        positioningContainerMaxHeight = _a.positioningContainerMaxHeight,\n        children = _a.children;\n    var positions = this.state.positions;\n    var styles = getClassNames();\n    var directionalClassName = positions && positions.targetEdge ? AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]] : '';\n    var getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;\n    var contentMaxHeight = positioningContainerMaxHeight && positioningContainerMaxHeight > getContentMaxHeight ? getContentMaxHeight : positioningContainerMaxHeight;\n    var content = React.createElement(\"div\", {\n      ref: this._positionedHost,\n      className: css('ms-PositioningContainer', styles.container)\n    }, React.createElement(\"div\", {\n      className: mergeStyles('ms-PositioningContainer-layerHost', styles.root, className, directionalClassName, !!positioningContainerWidth && {\n        width: positioningContainerWidth\n      }),\n      style: positions ? positions.elementPosition : OFF_SCREEN_STYLE,\n      // Safari and Firefox on Mac OS requires this to back-stop click events so focus remains in the Callout.\n      // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus\n      tabIndex: -1,\n      ref: this._contentHost\n    }, children, // @TODO apply to the content container\n    contentMaxHeight));\n    return this.props.doNotLayer ? content : React.createElement(Layer, null, content);\n  };\n\n  PositioningContainer.prototype._dismissOnScroll = function (ev) {\n    var preventDismissOnScroll = this.props.preventDismissOnScroll;\n\n    if (this.state.positions && !preventDismissOnScroll) {\n      this._dismissOnLostFocus(ev);\n    }\n  };\n\n  PositioningContainer.prototype._dismissOnLostFocus = function (ev) {\n    var target = ev.target;\n    var clickedOutsideCallout = this._positionedHost.current && !elementContains(this._positionedHost.current, target);\n\n    if (!this._target && clickedOutsideCallout || ev.target !== this._targetWindow && clickedOutsideCallout && (this._target.stopPropagation || !this._target || target !== this._target && !elementContains(this._target, target))) {\n      this.onResize(ev);\n    }\n  };\n\n  PositioningContainer.prototype._updateAsyncPosition = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      return _this._updatePosition();\n    });\n  };\n\n  PositioningContainer.prototype._updatePosition = function () {\n    var positions = this.state.positions;\n    var _a = this.props,\n        offsetFromTarget = _a.offsetFromTarget,\n        onPositioned = _a.onPositioned;\n    var hostElement = this._positionedHost.current;\n    var positioningContainerElement = this._contentHost.current;\n\n    if (hostElement && positioningContainerElement) {\n      var currentProps = __assign({}, this.props);\n\n      currentProps.bounds = this._getBounds();\n      currentProps.target = this._target;\n\n      if (document.body.contains(currentProps.target)) {\n        currentProps.gapSpace = offsetFromTarget;\n        var newPositions_1 = positionElement(currentProps, hostElement, positioningContainerElement); // Set the new position only when the positions are not exists or one of the new positioningContainer positions\n        // are different. The position should not change if the position is within 2 decimal places.\n\n        if (!positions && newPositions_1 || positions && newPositions_1 && !this._arePositionsEqual(positions, newPositions_1) && this._positionAttempts < 5) {\n          // We should not reposition the positioningContainer more than a few times, if it is then the content is\n          // likely resizing and we should stop trying to reposition to prevent a stack overflow.\n          this._positionAttempts++;\n          this.setState({\n            positions: newPositions_1\n          }, function () {\n            if (onPositioned) {\n              onPositioned(newPositions_1);\n            }\n          });\n        } else {\n          this._positionAttempts = 0;\n\n          if (onPositioned) {\n            onPositioned(newPositions_1);\n          }\n        }\n      } else if (positions !== undefined) {\n        this.setState({\n          positions: undefined\n        });\n      }\n    }\n  };\n\n  PositioningContainer.prototype._getBounds = function () {\n    if (!this._positioningBounds) {\n      var currentBounds = this.props.bounds;\n\n      if (!currentBounds) {\n        currentBounds = {\n          top: 0 + this.props.minPagePadding,\n          left: 0 + this.props.minPagePadding,\n          right: this._targetWindow.innerWidth - this.props.minPagePadding,\n          bottom: this._targetWindow.innerHeight - this.props.minPagePadding,\n          width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,\n          height: this._targetWindow.innerHeight - this.props.minPagePadding * 2\n        };\n      }\n\n      this._positioningBounds = currentBounds;\n    }\n\n    return this._positioningBounds;\n  };\n  /**\n   * Return the maximum height the container can grow to\n   * without going out of the specified bounds\n   */\n\n\n  PositioningContainer.prototype._getMaxHeight = function () {\n    var _a = this.props,\n        directionalHintFixed = _a.directionalHintFixed,\n        offsetFromTarget = _a.offsetFromTarget,\n        directionalHint = _a.directionalHint;\n\n    if (!this._maxHeight) {\n      if (directionalHintFixed && this._target) {\n        var gapSpace = offsetFromTarget ? offsetFromTarget : 0;\n        this._maxHeight = getMaxHeight(this._target, directionalHint, gapSpace, this._getBounds());\n      } else {\n        this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;\n      }\n    }\n\n    return this._maxHeight;\n  };\n\n  PositioningContainer.prototype._arePositionsEqual = function (positions, newPosition) {\n    return this._comparePositions(positions.elementPosition, newPosition.elementPosition);\n  };\n\n  PositioningContainer.prototype._comparePositions = function (oldPositions, newPositions) {\n    for (var key in newPositions) {\n      if (newPositions.hasOwnProperty(key)) {\n        var oldPositionEdge = oldPositions[key];\n        var newPositionEdge = newPositions[key];\n\n        if (oldPositionEdge && newPositionEdge) {\n          if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  };\n\n  PositioningContainer.prototype._setTargetWindowAndElement = function (target) {\n    var currentElement = this._positionedHost.current;\n\n    if (target) {\n      if (typeof target === 'string') {\n        var currentDoc = getDocument();\n        this._target = currentDoc ? currentDoc.querySelector(target) : null;\n        this._targetWindow = getWindow(currentElement); // Cast to any prevents error about stopPropagation always existing\n      } else if (target.stopPropagation) {\n        this._targetWindow = getWindow(target.target);\n        this._target = target;\n      } else if ( // eslint-disable-next-line deprecation/deprecation\n      (target.left !== undefined || target.x !== undefined) && ( // eslint-disable-next-line deprecation/deprecation\n      target.top !== undefined || target.y !== undefined)) {\n        this._targetWindow = getWindow(currentElement);\n        this._target = target;\n      } else {\n        var targetElement = target;\n        this._targetWindow = getWindow(targetElement);\n        this._target = target;\n      }\n    } else {\n      this._targetWindow = getWindow(currentElement);\n    }\n  };\n  /**\n   * Animates the height if finalHeight was given.\n   */\n\n\n  PositioningContainer.prototype._setHeightOffsetEveryFrame = function () {\n    var _this = this;\n\n    if (this._contentHost && this.props.finalHeight) {\n      this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {\n        if (!_this._contentHost.current) {\n          return;\n        }\n\n        var positioningContainerMainElem = _this._contentHost.current.lastChild;\n        var cardScrollHeight = positioningContainerMainElem.scrollHeight;\n        var cardCurrHeight = positioningContainerMainElem.offsetHeight;\n        var scrollDiff = cardScrollHeight - cardCurrHeight;\n\n        _this.setState({\n          heightOffset: _this.state.heightOffset + scrollDiff\n        });\n\n        if (positioningContainerMainElem.offsetHeight < _this.props.finalHeight) {\n          _this._setHeightOffsetEveryFrame();\n        } else {\n          _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer);\n        }\n      });\n    }\n  };\n\n  PositioningContainer.prototype._getTarget = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var target = props.target;\n    return target;\n  };\n\n  PositioningContainer.defaultProps = {\n    preventDismissOnScroll: false,\n    offsetFromTarget: 0,\n    minPagePadding: 8,\n    directionalHint: DirectionalHint.bottomAutoEdge\n  };\n  return PositioningContainer;\n}(React.Component);\n\nexport { PositioningContainer };","map":null,"metadata":{},"sourceType":"module"}