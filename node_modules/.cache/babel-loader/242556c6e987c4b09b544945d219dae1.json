{"ast":null,"code":"import { __assign, __decorate, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, classNamesFunction, divProperties, findIndex, getDocument, getFirstFocusable, getId, getLastFocusable, getNativeProps, initializeComponentRef, isIOS, isMac, mergeAriaAttributeValues, safeRequestAnimationFrame, warn, warnDeprecations, warnMutuallyExclusive } from '../../Utilities';\nimport { Callout } from '../../Callout';\nimport { Checkbox } from '../../Checkbox';\nimport { CommandButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { DropdownMenuItemType } from './Dropdown.types';\nimport { DropdownSizePosCache } from './utilities/DropdownSizePosCache';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Icon } from '../../Icon';\nimport { Label } from '../../Label';\nimport { KeytipData } from '../../KeytipData';\nimport { Panel } from '../../Panel';\nimport { ResponsiveMode, withResponsiveMode } from '../../utilities/decorators/withResponsiveMode';\nimport { SelectableOptionMenuItemType, getAllSelectedOptions } from '../../utilities/selectableOption/index';\nvar getClassNames = classNamesFunction();\n\nvar DropdownBase =\n/** @class */\nfunction (_super) {\n  __extends(DropdownBase, _super);\n\n  function DropdownBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._host = React.createRef();\n    _this._focusZone = React.createRef();\n    _this._dropDown = React.createRef();\n    _this._scrollIdleDelay = 250\n    /* ms */\n    ;\n    _this._sizePosCache = new DropdownSizePosCache();\n    _this._requestAnimationFrame = safeRequestAnimationFrame(_this);\n\n    _this._onChange = function (event, options, index, checked, multiSelect) {\n      // eslint-disable-next-line deprecation/deprecation\n      var _a = _this.props,\n          onChange = _a.onChange,\n          onChanged = _a.onChanged;\n\n      if (onChange || onChanged) {\n        // for single-select, option passed in will always be selected.\n        // for multi-select, flip the checked value\n        var changedOpt = multiSelect ? __assign(__assign({}, options[index]), {\n          selected: !checked\n        }) : options[index];\n        onChange && onChange(__assign(__assign({}, event), {\n          target: _this._dropDown.current\n        }), changedOpt, index);\n        onChanged && onChanged(changedOpt, index);\n      }\n    };\n    /** Get either props.placeholder (new name) or props.placeHolder (old name) */\n\n\n    _this._getPlaceholder = function () {\n      // eslint-disable-next-line deprecation/deprecation\n      return _this.props.placeholder || _this.props.placeHolder;\n    };\n    /** Get text in dropdown input as a string */\n\n\n    _this._getTitle = function (items, _unused) {\n      var _a = _this.props.multiSelectDelimiter,\n          multiSelectDelimiter = _a === void 0 ? ', ' : _a;\n      return items.map(function (i) {\n        return i.text;\n      }).join(multiSelectDelimiter);\n    };\n    /** Render text in dropdown input */\n\n\n    _this._onRenderTitle = function (items) {\n      return React.createElement(React.Fragment, null, _this._getTitle(items));\n    };\n    /** Render placeholder text in dropdown input */\n\n\n    _this._onRenderPlaceholder = function (props) {\n      if (!_this._getPlaceholder()) {\n        return null;\n      }\n\n      return React.createElement(React.Fragment, null, _this._getPlaceholder());\n    };\n    /** Render Callout or Panel container and pass in list */\n\n\n    _this._onRenderContainer = function (props) {\n      var calloutProps = props.calloutProps,\n          panelProps = props.panelProps;\n      var _a = _this.props,\n          responsiveMode = _a.responsiveMode,\n          dropdownWidth = _a.dropdownWidth;\n      var isSmall = responsiveMode <= ResponsiveMode.medium;\n      var panelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.panel : undefined;\n      return isSmall ? React.createElement(Panel, __assign({\n        isOpen: true,\n        isLightDismiss: true,\n        onDismiss: _this._onDismiss,\n        hasCloseButton: false,\n        styles: panelStyles\n      }, panelProps), _this._renderFocusableList(props)) : React.createElement(Callout, __assign({\n        isBeakVisible: false,\n        gapSpace: 0,\n        doNotLayer: false,\n        directionalHintFixed: false,\n        directionalHint: DirectionalHint.bottomLeftEdge\n      }, calloutProps, {\n        className: _this._classNames.callout,\n        target: _this._dropDown.current,\n        onDismiss: _this._onDismiss,\n        onScroll: _this._onScroll,\n        onPositioned: _this._onPositioned,\n        calloutWidth: dropdownWidth || (_this._dropDown.current ? _this._dropDown.current.clientWidth : 0)\n      }), _this._renderFocusableList(props));\n    };\n    /** Render Caret Down Icon */\n\n\n    _this._onRenderCaretDown = function (props) {\n      return React.createElement(Icon, {\n        className: _this._classNames.caretDown,\n        iconName: \"ChevronDown\",\n        \"aria-hidden\": true\n      });\n    };\n    /** Render List of items */\n\n\n    _this._onRenderList = function (props) {\n      var _a = props.onRenderItem,\n          onRenderItem = _a === void 0 ? _this._onRenderItem : _a;\n      var queue = {\n        items: []\n      };\n      var renderedList = [];\n\n      var emptyQueue = function emptyQueue() {\n        var newGroup = queue.id ? [React.createElement(\"div\", {\n          role: \"group\",\n          key: queue.id,\n          \"aria-labelledby\": queue.id\n        }, queue.items)] : queue.items;\n        renderedList = __spreadArrays(renderedList, newGroup); // Flush items and id\n\n        queue = {\n          items: []\n        };\n      };\n\n      var placeRenderedOptionIntoQueue = function placeRenderedOptionIntoQueue(item, index) {\n        /*\n          Case Header\n            empty queue if it's not already empty\n            ensure unique ID for header and set queue ID\n            push header into queue\n          Case Divider\n            push divider into queue if not first item\n            empty queue if not already empty\n          Default\n            push item into queue\n        */\n        switch (item.itemType) {\n          case SelectableOptionMenuItemType.Header:\n            queue.items.length > 0 && emptyQueue();\n            var id = _this._id + item.key;\n            queue.items.push(onRenderItem(__assign(__assign({\n              id: id\n            }, item), {\n              index: index\n            }), _this._onRenderItem));\n            queue.id = id;\n            break;\n\n          case SelectableOptionMenuItemType.Divider:\n            index > 0 && queue.items.push(onRenderItem(__assign(__assign({}, item), {\n              index: index\n            }), _this._onRenderItem));\n            queue.items.length > 0 && emptyQueue();\n            break;\n\n          default:\n            queue.items.push(onRenderItem(__assign(__assign({}, item), {\n              index: index\n            }), _this._onRenderItem));\n        }\n      }; // Place options into the queue. Queue will be emptied anytime a Header or Divider is encountered\n\n\n      props.options.forEach(function (item, index) {\n        placeRenderedOptionIntoQueue(item, index);\n      }); // Push remaining items into all renderedList\n\n      queue.items.length > 0 && emptyQueue();\n      return React.createElement(React.Fragment, null, renderedList);\n    };\n\n    _this._onRenderItem = function (item) {\n      switch (item.itemType) {\n        case SelectableOptionMenuItemType.Divider:\n          return _this._renderSeparator(item);\n\n        case SelectableOptionMenuItemType.Header:\n          return _this._renderHeader(item);\n\n        default:\n          return _this._renderOption(item);\n      }\n    };\n\n    _this._renderOption = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOption : _a;\n      var _b = _this.state.selectedIndices,\n          selectedIndices = _b === void 0 ? [] : _b;\n      var isItemSelected = item.index !== undefined && selectedIndices ? selectedIndices.indexOf(item.index) > -1 : false; // select the right className based on the combination of selected/disabled\n\n      var itemClassName = item.hidden // predicate: item hidden\n      ? _this._classNames.dropdownItemHidden : isItemSelected && item.disabled === true // predicate: both selected and disabled\n      ? _this._classNames.dropdownItemSelectedAndDisabled : isItemSelected // predicate: selected only\n      ? _this._classNames.dropdownItemSelected : item.disabled === true // predicate: disabled only\n      ? _this._classNames.dropdownItemDisabled : _this._classNames.dropdownItem;\n      var _c = item.title,\n          title = _c === void 0 ? item.text : _c;\n      var multiSelectItemStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.multiSelectItem : undefined;\n      return !_this.props.multiSelect ? React.createElement(CommandButton, {\n        id: _this._listId + item.index,\n        key: item.key,\n        \"data-index\": item.index,\n        \"data-is-focusable\": !item.disabled,\n        disabled: item.disabled,\n        className: itemClassName,\n        onClick: _this._onItemClick(item),\n        // eslint-disable-next-line react/jsx-no-bind\n        onMouseEnter: _this._onItemMouseEnter.bind(_this, item),\n        // eslint-disable-next-line react/jsx-no-bind\n        onMouseLeave: _this._onMouseItemLeave.bind(_this, item),\n        // eslint-disable-next-line react/jsx-no-bind\n        onMouseMove: _this._onItemMouseMove.bind(_this, item),\n        role: \"option\",\n        \"aria-selected\": isItemSelected ? 'true' : 'false',\n        ariaLabel: item.ariaLabel,\n        title: title,\n        \"aria-posinset\": _this._sizePosCache.positionInSet(item.index),\n        \"aria-setsize\": _this._sizePosCache.optionSetSize\n      }, onRenderOption(item, _this._onRenderOption)) : React.createElement(Checkbox, {\n        id: _this._listId + item.index,\n        key: item.key,\n        \"data-index\": item.index,\n        \"data-is-focusable\": !item.disabled,\n        disabled: item.disabled,\n        onChange: _this._onItemClick(item),\n        inputProps: {\n          'aria-selected': isItemSelected,\n          onMouseEnter: _this._onItemMouseEnter.bind(_this, item),\n          onMouseLeave: _this._onMouseItemLeave.bind(_this, item),\n          onMouseMove: _this._onItemMouseMove.bind(_this, item),\n          role: 'option'\n        },\n        label: item.text,\n        title: title,\n        // eslint-disable-next-line react/jsx-no-bind\n        onRenderLabel: _this._onRenderItemLabel.bind(_this, item),\n        className: itemClassName,\n        checked: isItemSelected,\n        styles: multiSelectItemStyles,\n        ariaPositionInSet: _this._sizePosCache.positionInSet(item.index),\n        ariaSetSize: _this._sizePosCache.optionSetSize\n      });\n    };\n    /** Render content of item (i.e. text/icon inside of button) */\n\n\n    _this._onRenderOption = function (item) {\n      return React.createElement(\"span\", {\n        className: _this._classNames.dropdownOptionText\n      }, item.text);\n    };\n    /** Render custom label for drop down item */\n\n\n    _this._onRenderItemLabel = function (item) {\n      var _a = _this.props.onRenderOption,\n          onRenderOption = _a === void 0 ? _this._onRenderOption : _a;\n      return onRenderOption(item, _this._onRenderOption);\n    };\n\n    _this._onPositioned = function (positions) {\n      if (_this._focusZone.current) {\n        // Focusing an element can trigger a reflow. Making this wait until there is an animation\n        // frame can improve perf significantly.\n        _this._requestAnimationFrame(function () {\n          var selectedIndices = _this.state.selectedIndices;\n\n          if (_this._focusZone.current) {\n            if (selectedIndices && selectedIndices[0] && !_this.props.options[selectedIndices[0]].disabled) {\n              var element = getDocument().getElementById(_this._id + \"-list\" + selectedIndices[0]);\n\n              if (element) {\n                _this._focusZone.current.focusElement(element);\n              }\n            } else {\n              _this._focusZone.current.focus();\n            }\n          }\n        });\n      }\n\n      if (!_this.state.calloutRenderEdge || _this.state.calloutRenderEdge !== positions.targetEdge) {\n        _this.setState({\n          calloutRenderEdge: positions.targetEdge\n        });\n      }\n    };\n\n    _this._onItemClick = function (item) {\n      return function (event) {\n        if (!item.disabled) {\n          _this.setSelectedIndex(event, item.index);\n\n          if (!_this.props.multiSelect) {\n            // only close the callout when it's in single-select mode\n            _this.setState({\n              isOpen: false\n            });\n          }\n        }\n      };\n    };\n    /**\n     * Scroll handler for the callout to make sure the mouse events\n     * for updating focus are not interacting during scroll\n     */\n\n\n    _this._onScroll = function () {\n      if (!_this._isScrollIdle && _this._scrollIdleTimeoutId !== undefined) {\n        clearTimeout(_this._scrollIdleTimeoutId);\n        _this._scrollIdleTimeoutId = undefined;\n      } else {\n        _this._isScrollIdle = false;\n      }\n\n      _this._scrollIdleTimeoutId = setTimeout(function () {\n        _this._isScrollIdle = true;\n      }, _this._scrollIdleDelay);\n    };\n\n    _this._onMouseItemLeave = function (item, ev) {\n      if (_this._shouldIgnoreMouseEvent()) {\n        return;\n      }\n      /**\n       * IE11 focus() method forces parents to scroll to top of element.\n       * Edge and IE expose a setActive() function for focusable divs that\n       * sets the page focus but does not scroll the parent element.\n       */\n\n\n      if (_this._host.current) {\n        if (_this._host.current.setActive) {\n          try {\n            _this._host.current.setActive();\n          } catch (e) {\n            /* no-op */\n          }\n        } else {\n          _this._host.current.focus();\n        }\n      }\n    };\n\n    _this._onDismiss = function () {\n      _this.setState({\n        isOpen: false\n      });\n    };\n\n    _this._onDropdownBlur = function (ev) {\n      // If Dropdown disabled do not proceed with this logic.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      } // hasFocus tracks whether the root element has focus so always update the state.\n\n\n      _this.setState({\n        hasFocus: false\n      });\n\n      if (_this.state.isOpen) {\n        // Do not onBlur when the callout is opened\n        return;\n      }\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onDropdownKeyDown = function (ev) {\n      // If Dropdown disabled do not process any keyboard events.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      } // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n\n\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n\n      if (_this.props.onKeyDown) {\n        _this.props.onKeyDown(ev);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      var newIndex;\n      var selectedIndex = _this.state.selectedIndices.length ? _this.state.selectedIndices[0] : -1;\n      var containsExpandCollapseModifier = ev.altKey || ev.metaKey;\n      var isOpen = _this.state.isOpen;\n\n      switch (ev.which) {\n        case KeyCodes.enter:\n          _this.setState({\n            isOpen: !isOpen\n          });\n\n          break;\n\n        case KeyCodes.escape:\n          if (!isOpen) {\n            return;\n          }\n\n          _this.setState({\n            isOpen: false\n          });\n\n          break;\n\n        case KeyCodes.up:\n          if (containsExpandCollapseModifier) {\n            if (isOpen) {\n              _this.setState({\n                isOpen: false\n              });\n\n              break;\n            }\n\n            return;\n          }\n\n          if (_this.props.multiSelect) {\n            _this.setState({\n              isOpen: true\n            });\n          } else if (!_this._isDisabled()) {\n            newIndex = _this._moveIndex(ev, -1, selectedIndex - 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.down:\n          if (containsExpandCollapseModifier) {\n            ev.stopPropagation();\n            ev.preventDefault();\n          }\n\n          if (containsExpandCollapseModifier && !isOpen || _this.props.multiSelect) {\n            _this.setState({\n              isOpen: true\n            });\n          } else if (!_this._isDisabled()) {\n            newIndex = _this._moveIndex(ev, 1, selectedIndex + 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.home:\n          if (!_this.props.multiSelect) {\n            newIndex = _this._moveIndex(ev, 1, 0, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.end:\n          if (!_this.props.multiSelect) {\n            newIndex = _this._moveIndex(ev, -1, _this.props.options.length - 1, selectedIndex);\n          }\n\n          break;\n\n        case KeyCodes.space:\n          // event handled in _onDropdownKeyUp\n          break;\n\n        default:\n          return;\n      }\n\n      if (newIndex !== selectedIndex) {\n        ev.stopPropagation();\n        ev.preventDefault();\n      }\n    };\n\n    _this._onDropdownKeyUp = function (ev) {\n      // If Dropdown disabled do not process any keyboard events.\n      var disabled = _this._isDisabled();\n\n      if (disabled) {\n        return;\n      }\n\n      var shouldHandleKey = _this._shouldHandleKeyUp(ev);\n\n      var isOpen = _this.state.isOpen;\n\n      if (_this.props.onKeyUp) {\n        _this.props.onKeyUp(ev);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      switch (ev.which) {\n        case KeyCodes.space:\n          _this.setState({\n            isOpen: !isOpen\n          });\n\n          break;\n\n        default:\n          if (shouldHandleKey && isOpen) {\n            _this.setState({\n              isOpen: false\n            });\n          }\n\n          return;\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onZoneKeyDown = function (ev) {\n      var elementToFocus; // Take note if we are processing an alt (option) or meta (command) keydown.\n      // See comment in _shouldHandleKeyUp for reasoning.\n\n      _this._lastKeyDownWasAltOrMeta = _this._isAltOrMeta(ev);\n      var containsExpandCollapseModifier = ev.altKey || ev.metaKey;\n\n      switch (ev.which) {\n        case KeyCodes.up:\n          if (containsExpandCollapseModifier) {\n            _this.setState({\n              isOpen: false\n            });\n          } else {\n            if (_this._host.current) {\n              elementToFocus = getLastFocusable(_this._host.current, _this._host.current.lastChild, true);\n            }\n          }\n\n          break;\n        // All directional keystrokes should be canceled when the zone is rendered.\n        // This avoids the body scroll from reacting and thus dismissing the dropdown.\n\n        case KeyCodes.home:\n        case KeyCodes.end:\n        case KeyCodes.pageUp:\n        case KeyCodes.pageDown:\n          break;\n\n        case KeyCodes.down:\n          if (!containsExpandCollapseModifier && _this._host.current) {\n            elementToFocus = getFirstFocusable(_this._host.current, _this._host.current.firstChild, true);\n          }\n\n          break;\n\n        case KeyCodes.escape:\n          _this.setState({\n            isOpen: false\n          });\n\n          break;\n\n        case KeyCodes.tab:\n          _this.setState({\n            isOpen: false\n          });\n\n          return;\n\n        default:\n          return;\n      }\n\n      if (elementToFocus) {\n        elementToFocus.focus();\n      }\n\n      ev.stopPropagation();\n      ev.preventDefault();\n    };\n\n    _this._onZoneKeyUp = function (ev) {\n      var shouldHandleKey = _this._shouldHandleKeyUp(ev);\n\n      if (shouldHandleKey && _this.state.isOpen) {\n        _this.setState({\n          isOpen: false\n        });\n\n        ev.preventDefault();\n      }\n    };\n\n    _this._onDropdownClick = function (ev) {\n      if (_this.props.onClick) {\n        _this.props.onClick(ev);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      var isOpen = _this.state.isOpen;\n\n      var disabled = _this._isDisabled();\n\n      if (!disabled && !_this._shouldOpenOnFocus()) {\n        _this.setState({\n          isOpen: !isOpen\n        });\n      }\n\n      _this._isFocusedByClick = false; // reset\n    };\n\n    _this._onDropdownMouseDown = function () {\n      _this._isFocusedByClick = true;\n    };\n\n    _this._onFocus = function (ev) {\n      var _a = _this.state,\n          isOpen = _a.isOpen,\n          selectedIndices = _a.selectedIndices;\n      var multiSelect = _this.props.multiSelect;\n\n      var disabled = _this._isDisabled();\n\n      if (!disabled) {\n        if (!_this._isFocusedByClick && !isOpen && selectedIndices.length === 0 && !multiSelect) {\n          // Per aria: https://www.w3.org/TR/wai-aria-practices-1.1/#listbox_kbd_interaction\n          _this._moveIndex(ev, 1, 0, -1);\n        }\n\n        if (_this.props.onFocus) {\n          _this.props.onFocus(ev);\n        }\n\n        var state = {\n          hasFocus: true\n        };\n\n        if (_this._shouldOpenOnFocus()) {\n          state.isOpen = true;\n        }\n\n        _this.setState(state);\n      }\n    };\n    /**\n     * Because the isDisabled prop is deprecated, we have had to repeat this logic all over the place.\n     * This helper method avoids all the repetition.\n     */\n\n\n    _this._isDisabled = function () {\n      var disabled = _this.props.disabled; // eslint-disable-next-line deprecation/deprecation\n\n      var isDisabled = _this.props.isDisabled; // Remove this deprecation workaround at 1.0.0\n\n      if (disabled === undefined) {\n        disabled = isDisabled;\n      }\n\n      return disabled;\n    };\n\n    _this._onRenderLabel = function (props) {\n      var label = props.label,\n          required = props.required,\n          disabled = props.disabled;\n      var labelStyles = _this._classNames.subComponentStyles ? _this._classNames.subComponentStyles.label : undefined;\n      return label ? React.createElement(Label, {\n        className: _this._classNames.label,\n        id: _this._labelId,\n        required: required,\n        styles: labelStyles,\n        disabled: disabled\n      }, label) : null;\n    };\n\n    initializeComponentRef(_this);\n    var multiSelect = props.multiSelect,\n        selectedKey = props.selectedKey,\n        selectedKeys = props.selectedKeys,\n        defaultSelectedKey = props.defaultSelectedKey,\n        defaultSelectedKeys = props.defaultSelectedKeys,\n        options = props.options;\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecations('Dropdown', props, {\n        isDisabled: 'disabled',\n        onChanged: 'onChange',\n        placeHolder: 'placeholder',\n        onRenderPlaceHolder: 'onRenderPlaceholder'\n      });\n      warnMutuallyExclusive('Dropdown', props, {\n        defaultSelectedKey: 'selectedKey',\n        defaultSelectedKeys: 'selectedKeys',\n        selectedKeys: 'selectedKey'\n      });\n\n      if (multiSelect) {\n        var warnMultiSelect = function warnMultiSelect(prop) {\n          return warn(\"Dropdown property '\" + prop + \"' cannot be used when 'multiSelect' is true. Use '\" + prop + \"s' instead.\");\n        };\n\n        if (selectedKey !== undefined) {\n          warnMultiSelect('selectedKey');\n        }\n\n        if (defaultSelectedKey !== undefined) {\n          warnMultiSelect('defaultSelectedKey');\n        }\n      } else {\n        var warnNotMultiSelect = function warnNotMultiSelect(prop) {\n          return warn(\"Dropdown property '\" + prop + \"s' cannot be used when 'multiSelect' is false/unset. Use '\" + prop + \"' instead.\");\n        };\n\n        if (selectedKeys !== undefined) {\n          warnNotMultiSelect('selectedKey');\n        }\n\n        if (defaultSelectedKeys !== undefined) {\n          warnNotMultiSelect('defaultSelectedKey');\n        }\n      }\n    }\n\n    _this._id = props.id || getId('Dropdown');\n    _this._labelId = _this._id + '-label';\n    _this._listId = _this._id + '-list';\n    _this._optionId = _this._id + '-option';\n    _this._isScrollIdle = true;\n    var selectedIndices;\n\n    if (multiSelect) {\n      selectedIndices = _this._getSelectedIndexes(options, defaultSelectedKeys !== undefined ? defaultSelectedKeys : selectedKeys);\n    } else {\n      selectedIndices = _this._getSelectedIndexes(options, defaultSelectedKey !== undefined ? defaultSelectedKey : selectedKey);\n    }\n\n    _this._sizePosCache.updateOptions(options);\n\n    _this.state = {\n      isOpen: false,\n      selectedIndices: selectedIndices,\n      hasFocus: false,\n      calloutRenderEdge: undefined\n    };\n    return _this;\n  }\n\n  Object.defineProperty(DropdownBase.prototype, \"selectedOptions\", {\n    /**\n     * All selected options\n     */\n    get: function get() {\n      var options = this.props.options;\n      var selectedIndices = this.state.selectedIndices;\n      return getAllSelectedOptions(options, selectedIndices);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  DropdownBase.prototype.componentWillUnmount = function () {\n    clearTimeout(this._scrollIdleTimeoutId);\n  };\n\n  DropdownBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    // In controlled component usage where selectedKey is provided, update the selectedIndex\n    // state if the key or options change.\n    var selectedKeyProp; // this does a shallow compare (assumes options are pure), for the purposes of determining whether\n    // defaultSelectedKey/defaultSelectedKeys are respected.\n\n    var didOptionsChange = newProps.options !== this.props.options;\n\n    if (newProps.multiSelect) {\n      if (didOptionsChange && newProps.defaultSelectedKeys !== undefined) {\n        selectedKeyProp = 'defaultSelectedKeys';\n      } else {\n        selectedKeyProp = 'selectedKeys';\n      }\n    } else {\n      if (didOptionsChange && newProps.defaultSelectedKey !== undefined) {\n        selectedKeyProp = 'defaultSelectedKey';\n      } else {\n        selectedKeyProp = 'selectedKey';\n      }\n    }\n\n    if (newProps[selectedKeyProp] !== undefined && (newProps[selectedKeyProp] !== this.props[selectedKeyProp] || didOptionsChange)) {\n      this.setState({\n        selectedIndices: this._getSelectedIndexes(newProps.options, newProps[selectedKeyProp])\n      });\n    }\n  };\n\n  DropdownBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.isOpen === true && this.state.isOpen === false) {\n      this._gotMouseMove = false;\n\n      if (this.props.onDismiss) {\n        this.props.onDismiss();\n      }\n    }\n  };\n\n  DropdownBase.prototype.render = function () {\n    var _this = this;\n\n    var _a, _b;\n\n    var id = this._id;\n    var props = this.props;\n    var className = props.className,\n        label = props.label,\n        options = props.options,\n        ariaLabel = props.ariaLabel,\n        required = props.required,\n        errorMessage = props.errorMessage,\n        keytipProps = props.keytipProps,\n        propStyles = props.styles,\n        theme = props.theme,\n        panelProps = props.panelProps,\n        calloutProps = props.calloutProps,\n        multiSelect = props.multiSelect,\n        _c = props.onRenderTitle,\n        onRenderTitle = _c === void 0 ? this._getTitle : _c,\n        _d = props.onRenderContainer,\n        onRenderContainer = _d === void 0 ? this._onRenderContainer : _d,\n        _e = props.onRenderCaretDown,\n        onRenderCaretDown = _e === void 0 ? this._onRenderCaretDown : _e,\n        _f = props.onRenderLabel,\n        onRenderLabel = _f === void 0 ? this._onRenderLabel : _f;\n    var _g = this.state,\n        isOpen = _g.isOpen,\n        selectedIndices = _g.selectedIndices,\n        calloutRenderEdge = _g.calloutRenderEdge; // eslint-disable-next-line deprecation/deprecation\n\n    var onRenderPlaceholder = props.onRenderPlaceholder || props.onRenderPlaceHolder || this._getPlaceholder; // If our cached options are out of date update our cache\n\n    if (options !== this._sizePosCache.cachedOptions) {\n      this._sizePosCache.updateOptions(options);\n    }\n\n    var selectedOptions = getAllSelectedOptions(options, selectedIndices);\n    var divProps = getNativeProps(props, divProperties);\n\n    var disabled = this._isDisabled();\n\n    var errorMessageId = id + '-errorMessage';\n    var ariaActiveDescendant = disabled ? undefined : isOpen && selectedIndices.length === 1 && selectedIndices[0] >= 0 ? this._listId + selectedIndices[0] : undefined;\n    var ariaAttrs = multiSelect ? {\n      role: 'button'\n    } : // single select\n    {\n      role: 'listbox',\n      childRole: 'option',\n      ariaRequired: required,\n      ariaSetSize: this._sizePosCache.optionSetSize,\n      ariaPosInSet: this._sizePosCache.positionInSet(selectedIndices[0]),\n      ariaSelected: selectedIndices[0] === undefined ? undefined : true\n    };\n    this._classNames = getClassNames(propStyles, {\n      theme: theme,\n      className: className,\n      hasError: !!(errorMessage && errorMessage.length > 0),\n      hasLabel: !!label,\n      isOpen: isOpen,\n      required: required,\n      disabled: disabled,\n      isRenderingPlaceholder: !selectedOptions.length,\n      panelClassName: (_a = panelProps) === null || _a === void 0 ? void 0 : _a.className,\n      calloutClassName: (_b = calloutProps) === null || _b === void 0 ? void 0 : _b.className,\n      calloutRenderEdge: calloutRenderEdge\n    });\n    var hasErrorMessage = !!errorMessage && errorMessage.length > 0;\n    return React.createElement(\"div\", {\n      className: this._classNames.root\n    }, onRenderLabel(this.props, this._onRenderLabel), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, keytipAttributes, {\n        \"data-is-focusable\": !disabled,\n        ref: _this._dropDown,\n        id: id,\n        tabIndex: disabled ? -1 : 0,\n        role: ariaAttrs.role,\n        \"aria-haspopup\": \"listbox\",\n        \"aria-expanded\": isOpen ? 'true' : 'false',\n        \"aria-label\": ariaLabel,\n        \"aria-labelledby\": label && !ariaLabel ? mergeAriaAttributeValues(_this._labelId, _this._optionId) : undefined,\n        \"aria-describedby\": mergeAriaAttributeValues(keytipAttributes['aria-describedby'], hasErrorMessage ? _this._id + '-errorMessage' : undefined),\n        \"aria-activedescendant\": ariaActiveDescendant,\n        \"aria-required\": ariaAttrs.ariaRequired,\n        \"aria-disabled\": disabled,\n        \"aria-owns\": isOpen ? _this._listId : undefined\n      }, divProps, {\n        className: _this._classNames.dropdown,\n        onBlur: _this._onDropdownBlur,\n        onKeyDown: _this._onDropdownKeyDown,\n        onKeyUp: _this._onDropdownKeyUp,\n        onClick: _this._onDropdownClick,\n        onMouseDown: _this._onDropdownMouseDown,\n        onFocus: _this._onFocus\n      }), React.createElement(\"span\", {\n        id: _this._optionId,\n        className: _this._classNames.title,\n        \"aria-live\": \"polite\",\n        \"aria-atomic\": true,\n        \"aria-invalid\": hasErrorMessage,\n        role: ariaAttrs.childRole,\n        \"aria-setsize\": ariaAttrs.ariaSetSize,\n        \"aria-posinset\": ariaAttrs.ariaPosInSet,\n        \"aria-selected\": ariaAttrs.ariaSelected\n      }, // If option is selected render title, otherwise render the placeholder text\n      selectedOptions.length ? onRenderTitle(selectedOptions, _this._onRenderTitle) : onRenderPlaceholder(props, _this._onRenderPlaceholder)), React.createElement(\"span\", {\n        className: _this._classNames.caretDownWrapper\n      }, onRenderCaretDown(props, _this._onRenderCaretDown)));\n    }), isOpen && onRenderContainer(__assign(__assign({}, props), {\n      onDismiss: this._onDismiss\n    }), this._onRenderContainer), hasErrorMessage && React.createElement(\"div\", {\n      role: \"alert\",\n      id: errorMessageId,\n      className: this._classNames.errorMessage\n    }, errorMessage));\n  };\n\n  DropdownBase.prototype.focus = function (shouldOpenOnFocus) {\n    if (this._dropDown.current) {\n      this._dropDown.current.focus();\n\n      if (shouldOpenOnFocus) {\n        this.setState({\n          isOpen: true\n        });\n      }\n    }\n  };\n\n  DropdownBase.prototype.setSelectedIndex = function (event, index) {\n    var _this = this;\n\n    var _a = this.props,\n        options = _a.options,\n        selectedKey = _a.selectedKey,\n        selectedKeys = _a.selectedKeys,\n        multiSelect = _a.multiSelect,\n        notifyOnReselect = _a.notifyOnReselect;\n    var _b = this.state.selectedIndices,\n        selectedIndices = _b === void 0 ? [] : _b;\n    var checked = selectedIndices ? selectedIndices.indexOf(index) > -1 : false;\n    var newIndexes = [];\n    index = Math.max(0, Math.min(options.length - 1, index)); // If this is a controlled component then no state change should take place.\n\n    if (selectedKey !== undefined || selectedKeys !== undefined) {\n      this._onChange(event, options, index, checked, multiSelect);\n\n      return;\n    }\n\n    if (!multiSelect && !notifyOnReselect && index === selectedIndices[0]) {\n      return;\n    } else if (multiSelect) {\n      newIndexes = selectedIndices ? this._copyArray(selectedIndices) : [];\n\n      if (checked) {\n        var position = newIndexes.indexOf(index);\n\n        if (position > -1) {\n          // unchecked the current one\n          newIndexes.splice(position, 1);\n        }\n      } else {\n        // add the new selected index into the existing one\n        newIndexes.push(index);\n      }\n    } else {\n      // Set the selected option if this is an uncontrolled component\n      newIndexes = [index];\n    }\n\n    event.persist(); // Call onChange after state is updated\n\n    this.setState({\n      selectedIndices: newIndexes\n    }, function () {\n      _this._onChange(event, options, index, checked, multiSelect);\n    });\n  };\n\n  DropdownBase.prototype._copyArray = function (array) {\n    var newArray = [];\n\n    for (var _i = 0, array_1 = array; _i < array_1.length; _i++) {\n      var element = array_1[_i];\n      newArray.push(element);\n    }\n\n    return newArray;\n  };\n  /**\n   * Finds the next valid Dropdown option and sets the selected index to it.\n   * @param stepValue - Value of how many items the function should traverse.  Should be -1 or 1.\n   * @param index - Index of where the search should start\n   * @param selectedIndex - The selectedIndex Dropdown's state\n   * @returns The next valid dropdown option's index\n   */\n\n\n  DropdownBase.prototype._moveIndex = function (event, stepValue, index, selectedIndex) {\n    var options = this.props.options; // Return selectedIndex if nothing has changed or options is empty\n\n    if (selectedIndex === index || options.length === 0) {\n      return selectedIndex;\n    } // If the user is pressing the up or down key we want to make\n    // sure that the dropdown cycles through the options without\n    // causing the screen to scroll. In _onDropdownKeyDown\n    // at the very end is a check to see if newIndex !== selectedIndex.\n    // If the index is less than 0 and we set it back to 0, then\n    // newIndex will equal selectedIndex and not stop the action\n    // of the key press happening and vice versa for indexes greater\n    // than or equal to the options length.\n\n\n    if (index >= options.length) {\n      index = 0;\n    } else if (index < 0) {\n      index = options.length - 1;\n    }\n\n    var stepCounter = 0; // If current index is a header or divider, or disabled, increment by step\n\n    while (options[index].itemType === DropdownMenuItemType.Header || options[index].itemType === DropdownMenuItemType.Divider || options[index].disabled) {\n      // If stepCounter exceeds length of options, then return selectedIndex (-1)\n      if (stepCounter >= options.length) {\n        return selectedIndex;\n      } // If index + stepValue is out of bounds, wrap around\n\n\n      if (index + stepValue < 0) {\n        index = options.length;\n      } else if (index + stepValue >= options.length) {\n        index = -1;\n      }\n\n      index = index + stepValue;\n      stepCounter++;\n    }\n\n    this.setSelectedIndex(event, index);\n    return index;\n  };\n  /** Wrap item list in a FocusZone */\n\n\n  DropdownBase.prototype._renderFocusableList = function (props) {\n    var _a = props.onRenderList,\n        onRenderList = _a === void 0 ? this._onRenderList : _a,\n        label = props.label,\n        ariaLabel = props.ariaLabel,\n        multiSelect = props.multiSelect;\n    return React.createElement(\"div\", {\n      className: this._classNames.dropdownItemsWrapper,\n      onKeyDown: this._onZoneKeyDown,\n      onKeyUp: this._onZoneKeyUp,\n      ref: this._host,\n      tabIndex: 0\n    }, React.createElement(FocusZone, {\n      ref: this._focusZone,\n      direction: FocusZoneDirection.vertical,\n      id: this._listId,\n      className: this._classNames.dropdownItems,\n      role: \"listbox\",\n      \"aria-label\": ariaLabel,\n      \"aria-labelledby\": label && !ariaLabel ? this._labelId : undefined,\n      \"aria-multiselectable\": multiSelect\n    }, onRenderList(props, this._onRenderList)));\n  };\n\n  DropdownBase.prototype._renderSeparator = function (item) {\n    var index = item.index,\n        key = item.key;\n\n    if (index > 0) {\n      return React.createElement(\"div\", {\n        role: \"separator\",\n        key: key,\n        className: this._classNames.dropdownDivider\n      });\n    }\n\n    return null;\n  };\n\n  DropdownBase.prototype._renderHeader = function (item) {\n    var _a = this.props.onRenderOption,\n        onRenderOption = _a === void 0 ? this._onRenderOption : _a;\n    var key = item.key,\n        id = item.id;\n    return React.createElement(\"div\", {\n      id: id,\n      key: key,\n      className: this._classNames.dropdownItemHeader\n    }, onRenderOption(item, this._onRenderOption));\n  };\n\n  DropdownBase.prototype._onItemMouseEnter = function (item, ev) {\n    if (this._shouldIgnoreMouseEvent()) {\n      return;\n    }\n\n    var targetElement = ev.currentTarget;\n    targetElement.focus();\n  };\n\n  DropdownBase.prototype._onItemMouseMove = function (item, ev) {\n    var targetElement = ev.currentTarget;\n    this._gotMouseMove = true;\n\n    if (!this._isScrollIdle || document.activeElement === targetElement) {\n      return;\n    }\n\n    targetElement.focus();\n  };\n\n  DropdownBase.prototype._shouldIgnoreMouseEvent = function () {\n    return !this._isScrollIdle || !this._gotMouseMove;\n  };\n  /** Get all selected indexes for multi-select mode */\n\n\n  DropdownBase.prototype._getSelectedIndexes = function (options, selectedKey) {\n    if (selectedKey === undefined) {\n      if (this.props.multiSelect) {\n        return this._getAllSelectedIndices(options);\n      }\n\n      var selectedIndex = this._getSelectedIndex(options, null);\n\n      return selectedIndex !== -1 ? [selectedIndex] : [];\n    } else if (!Array.isArray(selectedKey)) {\n      var selectedIndex = this._getSelectedIndex(options, selectedKey);\n\n      return selectedIndex !== -1 ? [selectedIndex] : [];\n    }\n\n    var selectedIndices = [];\n\n    for (var _i = 0, selectedKey_1 = selectedKey; _i < selectedKey_1.length; _i++) {\n      var key = selectedKey_1[_i];\n\n      var selectedIndex = this._getSelectedIndex(options, key);\n\n      selectedIndex !== -1 && selectedIndices.push(selectedIndex);\n    }\n\n    return selectedIndices;\n  };\n\n  DropdownBase.prototype._getAllSelectedIndices = function (options) {\n    return options.map(function (option, index) {\n      return option.selected ? index : -1;\n    }).filter(function (index) {\n      return index !== -1;\n    });\n  };\n\n  DropdownBase.prototype._getSelectedIndex = function (options, selectedKey) {\n    return findIndex(options, function (option) {\n      // eslint-disable-next-line eqeqeq\n      if (selectedKey != null) {\n        return option.key === selectedKey;\n      } else {\n        // eslint-disable-next-line deprecation/deprecation\n        return !!option.selected || !!option.isSelected;\n      }\n    });\n  };\n  /**\n   * Returns true if the key for the event is alt (Mac option) or meta (Mac command).\n   */\n\n\n  DropdownBase.prototype._isAltOrMeta = function (ev) {\n    return ev.which === KeyCodes.alt || ev.key === 'Meta';\n  };\n  /**\n   * We close the menu on key up only if ALL of the following are true:\n   * - Most recent key down was alt or meta (command)\n   * - The alt/meta key down was NOT followed by some other key (such as down/up arrow to\n   *   expand/collapse the menu)\n   * - We're not on a Mac (or iOS)\n   *\n   * This is because on Windows, pressing alt moves focus to the application menu bar or similar,\n   * closing any open context menus. There is not a similar behavior on Macs.\n   */\n\n\n  DropdownBase.prototype._shouldHandleKeyUp = function (ev) {\n    var keyPressIsAltOrMetaAlone = this._lastKeyDownWasAltOrMeta && this._isAltOrMeta(ev);\n\n    this._lastKeyDownWasAltOrMeta = false;\n    return !!keyPressIsAltOrMetaAlone && !(isMac() || isIOS());\n  };\n  /**\n   * Returns true if dropdown should set to open on focus.\n   * Otherwise, isOpen state should be toggled on click\n   */\n\n\n  DropdownBase.prototype._shouldOpenOnFocus = function () {\n    var hasFocus = this.state.hasFocus;\n    var openOnKeyboardFocus = this.props.openOnKeyboardFocus;\n    return !this._isFocusedByClick && openOnKeyboardFocus === true && !hasFocus;\n  };\n\n  DropdownBase.defaultProps = {\n    options: []\n  };\n  DropdownBase = __decorate([withResponsiveMode], DropdownBase);\n  return DropdownBase;\n}(React.Component);\n\nexport { DropdownBase };","map":null,"metadata":{},"sourceType":"module"}