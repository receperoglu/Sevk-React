{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { BaseDecorator } from './BaseDecorator';\nimport { findScrollableParent, getRect, getWindow, Async, EventGroup } from '../../Utilities';\nvar RESIZE_DELAY = 500;\nvar MAX_RESIZE_ATTEMPTS = 3;\n/**\n * A decorator to update decorated component on viewport or window resize events.\n *\n * @param ComposedComponent decorated React component reference.\n */\n\nexport function withViewport(ComposedComponent) {\n  return (\n    /** @class */\n    function (_super) {\n      __extends(WithViewportComponent, _super);\n\n      function WithViewportComponent(props) {\n        var _this = _super.call(this, props) || this;\n\n        _this._root = React.createRef();\n\n        _this._registerResizeObserver = function () {\n          var win = getWindow(_this._root.current);\n          _this._viewportResizeObserver = new win.ResizeObserver(_this._onAsyncResize);\n\n          _this._viewportResizeObserver.observe(_this._root.current);\n        };\n\n        _this._unregisterResizeObserver = function () {\n          if (_this._viewportResizeObserver) {\n            _this._viewportResizeObserver.disconnect();\n\n            delete _this._viewportResizeObserver;\n          }\n        };\n        /* Note: using lambda here because decorators don't seem to work in decorators. */\n\n\n        _this._updateViewport = function (withForceUpdate) {\n          var viewport = _this.state.viewport;\n          var viewportElement = _this._root.current;\n          var scrollElement = findScrollableParent(viewportElement);\n          var scrollRect = getRect(scrollElement);\n          var clientRect = getRect(viewportElement);\n\n          var updateComponent = function updateComponent() {\n            if (withForceUpdate && _this._composedComponentInstance) {\n              _this._composedComponentInstance.forceUpdate();\n            }\n          };\n\n          var isSizeChanged = (clientRect && clientRect.width) !== viewport.width || (scrollRect && scrollRect.height) !== viewport.height;\n\n          if (isSizeChanged && _this._resizeAttempts < MAX_RESIZE_ATTEMPTS && clientRect && scrollRect) {\n            _this._resizeAttempts++;\n\n            _this.setState({\n              viewport: {\n                width: clientRect.width,\n                height: scrollRect.height\n              }\n            }, function () {\n              _this._updateViewport(withForceUpdate);\n            });\n          } else {\n            _this._resizeAttempts = 0;\n            updateComponent();\n          }\n        };\n\n        _this._async = new Async(_this);\n        _this._events = new EventGroup(_this);\n        _this._resizeAttempts = 0;\n        _this.state = {\n          viewport: {\n            width: 0,\n            height: 0\n          }\n        };\n        return _this;\n      }\n\n      WithViewportComponent.prototype.componentDidMount = function () {\n        var _a = this.props,\n            skipViewportMeasures = _a.skipViewportMeasures,\n            disableResizeObserver = _a.disableResizeObserver;\n        var win = getWindow(this._root.current);\n        this._onAsyncResize = this._async.debounce(this._onAsyncResize, RESIZE_DELAY, {\n          leading: false\n        });\n\n        if (!skipViewportMeasures) {\n          if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n            this._registerResizeObserver();\n          } else {\n            this._events.on(win, 'resize', this._onAsyncResize);\n          }\n\n          this._updateViewport();\n        }\n      };\n\n      WithViewportComponent.prototype.componentDidUpdate = function (previousProps) {\n        var previousSkipViewportMeasures = previousProps.skipViewportMeasures;\n        var _a = this.props,\n            skipViewportMeasures = _a.skipViewportMeasures,\n            disableResizeObserver = _a.disableResizeObserver;\n        var win = getWindow(this._root.current);\n\n        if (skipViewportMeasures !== previousSkipViewportMeasures) {\n          if (!skipViewportMeasures) {\n            if (!disableResizeObserver && this._isResizeObserverAvailable()) {\n              if (!this._viewportResizeObserver) {\n                this._registerResizeObserver();\n              }\n            } else {\n              this._events.on(win, 'resize', this._onAsyncResize);\n            }\n\n            this._updateViewport();\n          } else {\n            this._unregisterResizeObserver();\n\n            this._events.off(win, 'resize', this._onAsyncResize);\n          }\n        }\n      };\n\n      WithViewportComponent.prototype.componentWillUnmount = function () {\n        this._events.dispose();\n\n        this._async.dispose();\n\n        this._unregisterResizeObserver();\n      };\n\n      WithViewportComponent.prototype.render = function () {\n        var viewport = this.state.viewport;\n        var newViewport = viewport.width > 0 && viewport.height > 0 ? viewport : undefined;\n        return React.createElement(\"div\", {\n          className: \"ms-Viewport\",\n          ref: this._root,\n          style: {\n            minWidth: 1,\n            minHeight: 1\n          }\n        }, React.createElement(ComposedComponent, __assign({\n          ref: this._updateComposedComponentRef,\n          viewport: newViewport\n        }, this.props)));\n      };\n\n      WithViewportComponent.prototype.forceUpdate = function () {\n        this._updateViewport(true);\n      };\n\n      WithViewportComponent.prototype._onAsyncResize = function () {\n        this._updateViewport();\n      };\n\n      WithViewportComponent.prototype._isResizeObserverAvailable = function () {\n        var win = getWindow(this._root.current);\n        return win && win.ResizeObserver;\n      };\n\n      return WithViewportComponent;\n    }(BaseDecorator)\n  );\n}","map":null,"metadata":{},"sourceType":"module"}