{"ast":null,"code":"import { __assign, __extends } from \"tslib\"; // Utilities\n\nimport * as React from 'react';\nimport { classNamesFunction, elementContains, focusFirstChild, getDocument, KeyCodes, shallowCompare, getRTL, warnDeprecations, EventGroup, Async, initializeComponentRef } from '../../Utilities';\nimport { RectangleEdge, getOppositeEdge } from '../../utilities/positioning'; // Component Dependencies\n\nimport { PositioningContainer } from './PositioningContainer/index';\nimport { Beak, BEAK_HEIGHT, BEAK_WIDTH } from './Beak/Beak';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { COACHMARK_HEIGHT, COACHMARK_WIDTH } from './Coachmark.styles';\nimport { FocusTrapZone } from '../../FocusTrapZone';\nvar getClassNames = classNamesFunction();\nexport var COACHMARK_ATTRIBUTE_NAME = 'data-coachmarkid';\nvar COMPONENT_NAME = 'Coachmark';\n\nvar CoachmarkBase =\n/** @class */\nfunction (_super) {\n  __extends(CoachmarkBase, _super);\n\n  function CoachmarkBase(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * The cached HTMLElement reference to the Entity Inner Host\n     * element.\n     */\n\n\n    _this._entityHost = React.createRef();\n    _this._entityInnerHostElement = React.createRef();\n    _this._translateAnimationContainer = React.createRef();\n    _this._ariaAlertContainer = React.createRef();\n    _this._childrenContainer = React.createRef();\n    _this._positioningContainer = React.createRef();\n\n    _this.dismiss = function (ev) {\n      var onDismiss = _this.props.onDismiss;\n\n      if (onDismiss) {\n        onDismiss(ev);\n      }\n    };\n\n    _this._onKeyDown = function (e) {\n      // Open coachmark if user presses ALT + C (arbitrary keypress for now)\n      if (e.altKey && e.which === KeyCodes.c || e.which === KeyCodes.enter && _this._translateAnimationContainer.current && _this._translateAnimationContainer.current.contains(e.target)) {\n        _this._onFocusHandler();\n      }\n    };\n\n    _this._onFocusHandler = function () {\n      if (_this.state.isCollapsed) {\n        _this._openCoachmark();\n      }\n    };\n\n    _this._onPositioned = function (positionData) {\n      _this._async.requestAnimationFrame(function () {\n        _this.setState({\n          targetAlignment: positionData.alignmentEdge,\n          targetPosition: positionData.targetEdge\n        });\n      });\n    };\n\n    _this._setBeakPosition = function () {\n      var beakLeft;\n      var beakTop;\n      var beakRight;\n      var beakBottom;\n      var transformOriginX;\n      var transformOriginY;\n      var targetAlignment = _this.state.targetAlignment;\n      var distanceAdjustment = '3px'; // Adjustment distance for Beak to shift towards Coachmark bubble.\n\n      switch (_this._beakDirection) {\n        // If Beak is pointing Up or Down\n        case RectangleEdge.top:\n        case RectangleEdge.bottom:\n          // If there is no target alignment, then beak is X-axis centered in callout\n          if (!targetAlignment) {\n            beakLeft = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginX = 'center';\n          } else {\n            // Beak is aligned to the left of target\n            if (targetAlignment === RectangleEdge.left) {\n              beakLeft = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'left';\n            } else {\n              // Beak is aligned to the right of target\n              beakRight = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginX = 'right';\n            }\n          }\n\n          if (_this._beakDirection === RectangleEdge.top) {\n            beakTop = distanceAdjustment;\n            transformOriginY = 'top';\n          } else {\n            beakBottom = distanceAdjustment;\n            transformOriginY = 'bottom';\n          }\n\n          break;\n        // If Beak is pointing Left or Right\n\n        case RectangleEdge.left:\n        case RectangleEdge.right:\n          // If there is no target alignment, then beak is Y-axis centered in callout\n          if (!targetAlignment) {\n            beakTop = \"calc(50% - \" + BEAK_WIDTH / 2 + \"px)\";\n            transformOriginY = \"center\";\n          } else {\n            // Beak is aligned to the top of target\n            if (targetAlignment === RectangleEdge.top) {\n              beakTop = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"top\";\n            } else {\n              // Beak is aligned to the bottom of target\n              beakBottom = COACHMARK_WIDTH / 2 - BEAK_WIDTH / 2 + \"px\";\n              transformOriginY = \"bottom\";\n            }\n          }\n\n          if (_this._beakDirection === RectangleEdge.left) {\n            if (getRTL(_this.props.theme)) {\n              beakRight = distanceAdjustment;\n            } else {\n              beakLeft = distanceAdjustment;\n            }\n\n            transformOriginX = 'left';\n          } else {\n            if (getRTL(_this.props.theme)) {\n              beakLeft = distanceAdjustment;\n            } else {\n              beakRight = distanceAdjustment;\n            }\n\n            transformOriginX = 'right';\n          }\n\n          break;\n      }\n\n      _this.setState({\n        beakLeft: beakLeft,\n        beakRight: beakRight,\n        beakBottom: beakBottom,\n        beakTop: beakTop,\n        transformOrigin: transformOriginX + \" \" + transformOriginY\n      });\n    };\n\n    _this._openCoachmark = function () {\n      _this.setState({\n        isCollapsed: false\n      });\n\n      if (_this.props.onAnimationOpenStart) {\n        _this.props.onAnimationOpenStart();\n      }\n\n      _this._entityInnerHostElement.current && _this._entityInnerHostElement.current.addEventListener('transitionend', function () {\n        // Need setTimeout to trigger narrator\n        _this._async.setTimeout(function () {\n          if (_this._entityInnerHostElement.current) {\n            focusFirstChild(_this._entityInnerHostElement.current);\n          }\n        }, 1000);\n\n        if (_this.props.onAnimationOpenEnd) {\n          _this.props.onAnimationOpenEnd();\n        }\n      });\n    };\n\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    initializeComponentRef(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      teachingBubbleRef: undefined,\n      collapsed: 'isCollapsed',\n      beakWidth: undefined,\n      beakHeight: undefined,\n      width: undefined,\n      height: undefined\n    }); // Set defaults for state\n\n    _this.state = {\n      isCollapsed: props.isCollapsed,\n      isBeaconAnimating: true,\n      isMeasuring: true,\n      entityInnerHostRect: {\n        width: 0,\n        height: 0\n      },\n      isMouseInProximity: false,\n      isMeasured: false\n    };\n    return _this;\n  }\n\n  Object.defineProperty(CoachmarkBase.prototype, \"_beakDirection\", {\n    get: function get() {\n      var targetPosition = this.state.targetPosition;\n\n      if (targetPosition === undefined) {\n        return RectangleEdge.bottom;\n      }\n\n      return getOppositeEdge(targetPosition);\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  CoachmarkBase.prototype.render = function () {\n    var _a = this.props,\n        beaconColorOne = _a.beaconColorOne,\n        beaconColorTwo = _a.beaconColorTwo,\n        children = _a.children,\n        target = _a.target,\n        color = _a.color,\n        positioningContainerProps = _a.positioningContainerProps,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        ariaDescribedByText = _a.ariaDescribedByText,\n        ariaLabelledBy = _a.ariaLabelledBy,\n        ariaLabelledByText = _a.ariaLabelledByText,\n        ariaAlertText = _a.ariaAlertText,\n        delayBeforeCoachmarkAnimation = _a.delayBeforeCoachmarkAnimation,\n        styles = _a.styles,\n        theme = _a.theme,\n        className = _a.className,\n        persistentBeak = _a.persistentBeak;\n    var _b = this.state,\n        beakLeft = _b.beakLeft,\n        beakTop = _b.beakTop,\n        beakRight = _b.beakRight,\n        beakBottom = _b.beakBottom,\n        isCollapsed = _b.isCollapsed,\n        isBeaconAnimating = _b.isBeaconAnimating,\n        isMeasuring = _b.isMeasuring,\n        entityInnerHostRect = _b.entityInnerHostRect,\n        transformOrigin = _b.transformOrigin,\n        alertText = _b.alertText,\n        isMeasured = _b.isMeasured; // Defaulting the main background before passing it to the styles because it is used for `Beak` too.\n\n    var defaultColor = color;\n\n    if (!defaultColor && theme) {\n      defaultColor = theme.semanticColors.primaryButtonBackground;\n    }\n\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      beaconColorOne: beaconColorOne,\n      beaconColorTwo: beaconColorTwo,\n      className: className,\n      isCollapsed: isCollapsed,\n      isBeaconAnimating: isBeaconAnimating,\n      isMeasuring: isMeasuring,\n      color: defaultColor,\n      transformOrigin: transformOrigin,\n      isMeasured: isMeasured,\n      entityHostHeight: entityInnerHostRect.height + \"px\",\n      entityHostWidth: entityInnerHostRect.width + \"px\",\n      width: COACHMARK_WIDTH + \"px\",\n      height: COACHMARK_HEIGHT + \"px\",\n      delayBeforeCoachmarkAnimation: delayBeforeCoachmarkAnimation + \"ms\"\n    });\n    var finalHeight = isCollapsed ? COACHMARK_HEIGHT : entityInnerHostRect.height;\n    return React.createElement(PositioningContainer, __assign({\n      target: target,\n      offsetFromTarget: BEAK_HEIGHT,\n      componentRef: this._positioningContainer,\n      finalHeight: finalHeight,\n      onPositioned: this._onPositioned,\n      bounds: this._getBounds()\n    }, positioningContainerProps), React.createElement(\"div\", {\n      className: classNames.root\n    }, ariaAlertText && React.createElement(\"div\", {\n      className: classNames.ariaContainer,\n      role: \"alert\",\n      ref: this._ariaAlertContainer,\n      \"aria-hidden\": !isCollapsed\n    }, alertText), React.createElement(\"div\", {\n      className: classNames.pulsingBeacon\n    }), React.createElement(\"div\", {\n      className: classNames.translateAnimationContainer,\n      ref: this._translateAnimationContainer\n    }, React.createElement(\"div\", {\n      className: classNames.scaleAnimationLayer\n    }, React.createElement(\"div\", {\n      className: classNames.rotateAnimationLayer\n    }, this._positioningContainer.current && (isCollapsed || persistentBeak) && React.createElement(Beak, {\n      left: beakLeft,\n      top: beakTop,\n      right: beakRight,\n      bottom: beakBottom,\n      direction: this._beakDirection,\n      color: defaultColor\n    }), React.createElement(\"div\", {\n      className: classNames.entityHost,\n      ref: this._entityHost,\n      tabIndex: -1,\n      \"data-is-focusable\": true,\n      role: \"dialog\",\n      \"aria-labelledby\": ariaLabelledBy,\n      \"aria-describedby\": ariaDescribedBy\n    }, isCollapsed && [ariaLabelledBy && React.createElement(\"p\", {\n      id: ariaLabelledBy,\n      key: 0,\n      className: classNames.ariaContainer\n    }, ariaLabelledByText), ariaDescribedBy && React.createElement(\"p\", {\n      id: ariaDescribedBy,\n      key: 1,\n      className: classNames.ariaContainer\n    }, ariaDescribedByText)], React.createElement(FocusTrapZone, {\n      isClickableOutsideFocusTrap: true,\n      forceFocusInsideTrap: false\n    }, React.createElement(\"div\", {\n      className: classNames.entityInnerHost,\n      ref: this._entityInnerHostElement\n    }, React.createElement(\"div\", {\n      className: classNames.childrenContainer,\n      ref: this._childrenContainer,\n      \"aria-hidden\": isCollapsed\n    }, children)))))))));\n  };\n\n  CoachmarkBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (this.props.isCollapsed && !newProps.isCollapsed) {\n      // The coachmark is about to open\n      this._openCoachmark();\n    }\n  };\n\n  CoachmarkBase.prototype.shouldComponentUpdate = function (newProps, newState) {\n    return !shallowCompare(newProps, this.props) || !shallowCompare(newState, this.state);\n  };\n\n  CoachmarkBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    if (prevState.targetAlignment !== this.state.targetAlignment || prevState.targetPosition !== this.state.targetPosition) {\n      this._setBeakPosition();\n    }\n\n    if (prevProps.preventDismissOnLostFocus !== this.props.preventDismissOnLostFocus) {\n      this._addListeners();\n    }\n  };\n\n  CoachmarkBase.prototype.componentDidMount = function () {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      if (_this._entityInnerHostElement.current && _this.state.entityInnerHostRect.width + _this.state.entityInnerHostRect.width === 0) {\n        _this.setState({\n          isMeasuring: false,\n          entityInnerHostRect: {\n            width: _this._entityInnerHostElement.current.offsetWidth,\n            height: _this._entityInnerHostElement.current.offsetHeight\n          },\n          isMeasured: true\n        });\n\n        _this._setBeakPosition();\n\n        _this.forceUpdate();\n      }\n\n      _this._addListeners(); // We don't want to the user to immediately trigger the Coachmark when it's opened\n\n\n      _this._async.setTimeout(function () {\n        _this._addProximityHandler(_this.props.mouseProximityOffset);\n      }, _this.props.delayBeforeMouseOpen); // Need to add setTimeout to have narrator read change in alert container\n\n\n      if (_this.props.ariaAlertText) {\n        _this._async.setTimeout(function () {\n          if (_this.props.ariaAlertText && _this._ariaAlertContainer.current) {\n            _this.setState({\n              alertText: _this.props.ariaAlertText\n            });\n          }\n        }, 0);\n      }\n\n      if (!_this.props.preventFocusOnMount) {\n        _this._async.setTimeout(function () {\n          if (_this._entityHost.current) {\n            _this._entityHost.current.focus();\n          }\n        }, 1000);\n      }\n    });\n  };\n\n  CoachmarkBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  CoachmarkBase.prototype._addListeners = function () {\n    var preventDismissOnLostFocus = this.props.preventDismissOnLostFocus;\n    var currentDoc = getDocument();\n\n    this._events.off();\n\n    if (currentDoc) {\n      this._events.on(currentDoc, 'keydown', this._onKeyDown, true);\n\n      if (!preventDismissOnLostFocus) {\n        this._events.on(currentDoc, 'click', this._dismissOnLostFocus, true);\n\n        this._events.on(currentDoc, 'focus', this._dismissOnLostFocus, true);\n      }\n    }\n  };\n\n  CoachmarkBase.prototype._dismissOnLostFocus = function (ev) {\n    var clickTarget = ev.target;\n    var clickedOutsideCallout = this._translateAnimationContainer.current && !elementContains(this._translateAnimationContainer.current, clickTarget);\n    var target = this.props.target;\n\n    if (clickedOutsideCallout && clickTarget !== target && !elementContains(target, clickTarget)) {\n      this.dismiss(ev);\n    }\n  };\n\n  CoachmarkBase.prototype._getBounds = function () {\n    var _a = this.props,\n        isPositionForced = _a.isPositionForced,\n        positioningContainerProps = _a.positioningContainerProps;\n\n    if (isPositionForced) {\n      // If directionalHint direction is the top or bottom auto edge, then we want to set the left/right bounds\n      // to the window x-axis to have auto positioning work correctly.\n      if (positioningContainerProps && (positioningContainerProps.directionalHint === DirectionalHint.topAutoEdge || positioningContainerProps.directionalHint === DirectionalHint.bottomAutoEdge)) {\n        return {\n          left: 0,\n          top: -Infinity,\n          bottom: Infinity,\n          right: window.innerWidth,\n          width: window.innerWidth,\n          height: Infinity\n        };\n      } else {\n        return {\n          left: -Infinity,\n          top: -Infinity,\n          bottom: Infinity,\n          right: Infinity,\n          width: Infinity,\n          height: Infinity\n        };\n      }\n    } else {\n      return undefined;\n    }\n  };\n\n  CoachmarkBase.prototype._addProximityHandler = function (mouseProximityOffset) {\n    var _this = this;\n\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n    /**\n     * An array of cached ids returned when setTimeout runs during\n     * the window resize event trigger.\n     */\n\n\n    var timeoutIds = []; // Take the initial measure out of the initial render to prevent\n    // an unnecessary render.\n\n    this._async.setTimeout(function () {\n      _this._setTargetElementRect(); // When the window resizes we want to async\n      // get the bounding client rectangle.\n      // Every time the event is triggered we want to\n      // setTimeout and then clear any previous instances\n      // of setTimeout.\n\n\n      _this._events.on(window, 'resize', function () {\n        timeoutIds.forEach(function (value) {\n          clearInterval(value);\n        });\n        timeoutIds.push(_this._async.setTimeout(function () {\n          _this._setTargetElementRect();\n        }, 100));\n      });\n    }, 10); // Every time the document's mouse move is triggered\n    // we want to check if inside of an element and\n    // set the state with the result.\n\n\n    this._events.on(document, 'mousemove', function (e) {\n      if (_this.state.isCollapsed) {\n        var mouseY = e.clientY;\n        var mouseX = e.clientX;\n\n        _this._setTargetElementRect();\n\n        var isMouseInProximity = _this._isInsideElement(mouseX, mouseY, mouseProximityOffset);\n\n        if (isMouseInProximity !== _this.state.isMouseInProximity) {\n          _this._openCoachmark();\n        }\n      }\n\n      if (_this.props.onMouseMove) {\n        _this.props.onMouseMove(e);\n      }\n    });\n  };\n\n  CoachmarkBase.prototype._setTargetElementRect = function () {\n    if (this._translateAnimationContainer && this._translateAnimationContainer.current) {\n      this._targetElementRect = this._translateAnimationContainer.current.getBoundingClientRect();\n    }\n  };\n\n  CoachmarkBase.prototype._isInsideElement = function (mouseX, mouseY, mouseProximityOffset) {\n    if (mouseProximityOffset === void 0) {\n      mouseProximityOffset = 0;\n    }\n\n    return mouseX > this._targetElementRect.left - mouseProximityOffset && mouseX < this._targetElementRect.left + this._targetElementRect.width + mouseProximityOffset && mouseY > this._targetElementRect.top - mouseProximityOffset && mouseY < this._targetElementRect.top + this._targetElementRect.height + mouseProximityOffset;\n  };\n\n  CoachmarkBase.defaultProps = {\n    isCollapsed: true,\n    mouseProximityOffset: 10,\n    delayBeforeMouseOpen: 3600,\n    delayBeforeCoachmarkAnimation: 0,\n    isPositionForced: true,\n    positioningContainerProps: {\n      directionalHint: DirectionalHint.bottomAutoEdge\n    }\n  };\n  return CoachmarkBase;\n}(React.Component);\n\nexport { CoachmarkBase };","map":null,"metadata":{},"sourceType":"module"}