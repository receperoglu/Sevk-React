{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { classNamesFunction, initializeComponentRef, warnDeprecations, warn } from '../../Utilities';\nimport { TextField } from '../../TextField';\nimport { ColorRectangle } from './ColorRectangle/ColorRectangle';\nimport { ColorSlider } from './ColorSlider/ColorSlider';\nimport { MAX_COLOR_ALPHA, MAX_COLOR_RGB, MAX_HEX_LENGTH, MAX_RGBA_LENGTH, MIN_HEX_LENGTH, MIN_RGBA_LENGTH, HEX_REGEX, RGBA_REGEX } from '../../utilities/color/consts';\nimport { getColorFromString } from '../../utilities/color/getColorFromString';\nimport { getColorFromRGBA } from '../../utilities/color/getColorFromRGBA';\nimport { clamp } from '../../utilities/color/clamp';\nimport { updateA } from '../../utilities/color/updateA';\nimport { updateT } from '../../utilities/color/updateT';\nimport { updateH } from '../../utilities/color/updateH';\nimport { correctRGB } from '../../utilities/color/correctRGB';\nimport { correctHex } from '../../utilities/color/correctHex';\nimport { ColorRectangleBase } from './ColorRectangle/ColorRectangle.base';\nvar getClassNames = classNamesFunction();\nvar allColorComponents = ['hex', 'r', 'g', 'b', 'a', 't'];\n/**\n * {@docCategory ColorPicker}\n */\n\nvar ColorPickerBase =\n/** @class */\nfunction (_super) {\n  __extends(ColorPickerBase, _super);\n\n  function ColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._onSVChanged = function (ev, color) {\n      _this._updateColor(ev, color);\n    };\n\n    _this._onHChanged = function (ev, h) {\n      _this._updateColor(ev, updateH(_this.state.color, h));\n    };\n    /** Callback for when the alpha/transparency slider changes */\n\n\n    _this._onATChanged = function (ev, value) {\n      var updater = _this.props.alphaType === 'transparency' ? updateT : updateA;\n\n      _this._updateColor(ev, updater(_this.state.color, Math.round(value)));\n    };\n\n    _this._onBlur = function (event) {\n      var _a;\n\n      var _b = _this.state,\n          color = _b.color,\n          editingColor = _b.editingColor;\n\n      if (!editingColor) {\n        return;\n      } // If there was an intermediate incorrect value (such as too large or empty), correct it.\n\n\n      var value = editingColor.value,\n          component = editingColor.component;\n      var isHex = component === 'hex';\n      var isAlpha = component === 'a';\n      var isTransparency = component === 't';\n      var minLength = isHex ? MIN_HEX_LENGTH : MIN_RGBA_LENGTH;\n\n      if (value.length >= minLength && (isHex || !isNaN(Number(value)))) {\n        // Real value. Clamp to appropriate length (hex) or range (rgba).\n        var newColor = void 0;\n\n        if (isHex) {\n          newColor = getColorFromString('#' + correctHex(value));\n        } else if (isAlpha || isTransparency) {\n          var updater = isAlpha ? updateA : updateT;\n          newColor = updater(color, clamp(Number(value), MAX_COLOR_ALPHA));\n        } else {\n          newColor = getColorFromRGBA(correctRGB(__assign(__assign({}, color), (_a = {}, _a[component] = Number(value), _a))));\n        } // Update state and call onChange\n\n\n        _this._updateColor(event, newColor);\n      } else {\n        // Intermediate value was an empty string or too short (hex only).\n        // Just clear the intermediate state and revert to the previous value.\n        _this.setState({\n          editingColor: undefined\n        });\n      }\n    };\n\n    initializeComponentRef(_this);\n    var strings = props.strings; // always defined since it's in defaultProps\n\n    warnDeprecations('ColorPicker', props, {\n      hexLabel: 'strings.hex',\n      redLabel: 'strings.red',\n      greenLabel: 'strings.green',\n      blueLabel: 'strings.blue',\n      alphaLabel: 'strings.alpha',\n      alphaSliderHidden: 'alphaType'\n    }); // eslint-disable-next-line deprecation/deprecation\n\n    if (strings.hue) {\n      // warnDeprecations can't handle nested deprecated props\n      warn(\"ColorPicker property 'strings.hue' was used but has been deprecated. Use 'strings.hueAriaLabel' instead.\");\n    }\n\n    _this.state = {\n      color: _getColorFromProps(props) || getColorFromString('#ffffff')\n    };\n    _this._textChangeHandlers = {};\n\n    for (var _i = 0, allColorComponents_1 = allColorComponents; _i < allColorComponents_1.length; _i++) {\n      var component = allColorComponents_1[_i];\n      _this._textChangeHandlers[component] = _this._onTextChange.bind(_this, component);\n    }\n\n    var defaultStrings = ColorPickerBase.defaultProps.strings;\n    _this._textLabels = {\n      /* eslint-disable deprecation/deprecation */\n      r: props.redLabel || strings.red || defaultStrings.red,\n      g: props.greenLabel || strings.green || defaultStrings.green,\n      b: props.blueLabel || strings.blue || defaultStrings.blue,\n      a: props.alphaLabel || strings.alpha || defaultStrings.alpha,\n      hex: props.hexLabel || strings.hex || defaultStrings.hex,\n      t: strings.transparency || defaultStrings.transparency\n    };\n    _this._strings = __assign(__assign(__assign({}, defaultStrings), {\n      // these aria labels default to the visible labels\n      alphaAriaLabel: _this._textLabels.a,\n      transparencyAriaLabel: _this._textLabels.t\n    }), strings);\n    return _this;\n  }\n\n  Object.defineProperty(ColorPickerBase.prototype, \"color\", {\n    get: function get() {\n      return this.state.color;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  ColorPickerBase.prototype.componentDidUpdate = function (prevProps, prevState) {\n    // if props changed (as opposed to a state update), update the color\n    if (prevProps !== this.props) {\n      var color = _getColorFromProps(this.props);\n\n      if (color) {\n        this._updateColor(undefined, color);\n      }\n    }\n  };\n\n  ColorPickerBase.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var strings = this._strings;\n    var textLabels = this._textLabels;\n    var theme = props.theme,\n        className = props.className,\n        styles = props.styles,\n        alphaType = props.alphaType,\n        // eslint-disable-next-line deprecation/deprecation\n    _a = props.alphaSliderHidden,\n        // eslint-disable-next-line deprecation/deprecation\n    alphaSliderHidden = _a === void 0 ? alphaType === 'none' : _a;\n    var color = this.state.color;\n    var useTransparency = alphaType === 'transparency';\n    var colorComponents = ['hex', 'r', 'g', 'b', useTransparency ? 't' : 'a'];\n    var atValue = useTransparency ? color.t : color.a;\n    var atLabel = useTransparency ? textLabels.t : textLabels.a;\n    var classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      alphaType: alphaType\n    });\n    var selectedColorAriaParts = [textLabels.r, color.r, textLabels.g, color.g, textLabels.b, color.b];\n\n    if (!alphaSliderHidden && typeof atValue === 'number') {\n      selectedColorAriaParts.push(atLabel, atValue + \"%\");\n    }\n\n    var ariaLabel = strings.rootAriaLabelFormat.replace('{0}', selectedColorAriaParts.join(' '));\n    return React.createElement(\"div\", {\n      className: classNames.root,\n      role: \"group\",\n      \"aria-label\": ariaLabel\n    }, React.createElement(\"div\", {\n      className: classNames.panel\n    }, React.createElement(ColorRectangle, {\n      color: color,\n      onChange: this._onSVChanged,\n      ariaLabel: strings.svAriaLabel,\n      ariaDescription: strings.svAriaDescription,\n      ariaValueFormat: strings.svAriaValueFormat,\n      className: classNames.colorRectangle\n    }), React.createElement(\"div\", {\n      className: classNames.flexContainer\n    }, React.createElement(\"div\", {\n      className: classNames.flexSlider\n    }, React.createElement(ColorSlider, {\n      className: \"is-hue\",\n      type: \"hue\",\n      // eslint-disable-next-line deprecation/deprecation\n      ariaLabel: strings.hue || strings.hueAriaLabel,\n      value: color.h,\n      onChange: this._onHChanged\n    }), !alphaSliderHidden && React.createElement(ColorSlider, {\n      className: \"is-alpha\",\n      type: alphaType,\n      ariaLabel: useTransparency ? strings.transparencyAriaLabel : strings.alphaAriaLabel,\n      overlayColor: color.hex,\n      value: atValue,\n      onChange: this._onATChanged\n    })), props.showPreview && React.createElement(\"div\", {\n      className: classNames.flexPreviewBox\n    }, React.createElement(\"div\", {\n      className: classNames.colorSquare + ' is-preview',\n      style: {\n        backgroundColor: color.str\n      }\n    }))), React.createElement(\"table\", {\n      className: classNames.table,\n      role: \"group\",\n      cellPadding: \"0\",\n      cellSpacing: \"0\"\n    }, React.createElement(\"thead\", null, React.createElement(\"tr\", {\n      className: classNames.tableHeader\n    }, React.createElement(\"td\", {\n      className: classNames.tableHexCell\n    }, textLabels.hex), React.createElement(\"td\", null, textLabels.r), React.createElement(\"td\", null, textLabels.g), React.createElement(\"td\", null, textLabels.b), !alphaSliderHidden && React.createElement(\"td\", {\n      className: classNames.tableAlphaCell\n    }, atLabel))), React.createElement(\"tbody\", null, React.createElement(\"tr\", null, colorComponents.map(function (comp) {\n      if ((comp === 'a' || comp === 't') && alphaSliderHidden) {\n        return null;\n      }\n\n      return React.createElement(\"td\", {\n        key: comp\n      }, React.createElement(TextField, {\n        className: classNames.input,\n        onChange: _this._textChangeHandlers[comp],\n        onBlur: _this._onBlur,\n        value: _this._getDisplayValue(comp),\n        spellCheck: false,\n        ariaLabel: textLabels[comp],\n        \"aria-live\": comp !== 'hex' ? 'assertive' : undefined,\n        autoComplete: \"off\"\n      }));\n    }))))));\n  };\n\n  ColorPickerBase.prototype._getDisplayValue = function (component) {\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor;\n\n    if (editingColor && editingColor.component === component) {\n      return editingColor.value;\n    }\n\n    if (component === 'hex') {\n      return color[component] || '';\n    } else if (typeof color[component] === 'number' && !isNaN(color[component])) {\n      return String(color[component]);\n    }\n\n    return '';\n  };\n\n  ColorPickerBase.prototype._onTextChange = function (component, event, newValue) {\n    var _a;\n\n    var color = this.state.color;\n    var isHex = component === 'hex';\n    var isAlpha = component === 'a';\n    var isTransparency = component === 't';\n    newValue = (newValue || '').substr(0, isHex ? MAX_HEX_LENGTH : MAX_RGBA_LENGTH); // Ignore what the user typed if it contains invalid characters\n\n    var validCharsRegex = isHex ? HEX_REGEX : RGBA_REGEX;\n\n    if (!validCharsRegex.test(newValue)) {\n      return;\n    } // Determine if the entry is valid (different methods for hex, alpha, and RGB)\n\n\n    var isValid;\n\n    if (newValue === '') {\n      // Empty string is obviously not valid\n      isValid = false;\n    } else if (isHex) {\n      // Technically hex values of length 3 are also valid, but committing the value here would\n      // cause it to be automatically converted to a value of length 6, which may not be what the\n      // user wanted if they're not finished typing. (Values of length 3 will be committed on blur.)\n      isValid = newValue.length === MAX_HEX_LENGTH;\n    } else if (isAlpha || isTransparency) {\n      isValid = Number(newValue) <= MAX_COLOR_ALPHA;\n    } else {\n      isValid = Number(newValue) <= MAX_COLOR_RGB;\n    }\n\n    if (!isValid) {\n      // If the new value is an empty string or other invalid value, save that to display.\n      // (if the user still hasn't entered anything on blur, the last value is restored)\n      this.setState({\n        editingColor: {\n          component: component,\n          value: newValue\n        }\n      });\n    } else if (String(color[component]) === newValue) {\n      // If the new value is the same as the current value, mostly ignore it.\n      // Exception is that if the user was previously editing the value (but hadn't yet entered\n      // a new valid value), we should clear the intermediate value.\n      if (this.state.editingColor) {\n        this.setState({\n          editingColor: undefined\n        });\n      }\n    } else {\n      // Should be a valid color. Update the value.\n      var newColor = isHex ? getColorFromString('#' + newValue) : isTransparency ? updateT(color, Number(newValue)) : getColorFromRGBA(__assign(__assign({}, color), (_a = {}, _a[component] = Number(newValue), _a)));\n\n      this._updateColor(event, newColor);\n    }\n  };\n  /**\n   * Update the displayed color and call change handlers if appropriate.\n   * @param ev - Event if call was triggered by an event (undefined if triggered by props change)\n   * @param newColor - Updated color\n   */\n\n\n  ColorPickerBase.prototype._updateColor = function (ev, newColor) {\n    if (!newColor) {\n      return;\n    }\n\n    var _a = this.state,\n        color = _a.color,\n        editingColor = _a.editingColor; // For black or white, the hue can change without changing the string.\n\n    var isDifferentColor = newColor.h !== color.h || newColor.str !== color.str;\n\n    if (isDifferentColor || editingColor) {\n      // If ev is undefined, it's an update from props (which should be unconditionally respected\n      // and not call onChange).\n      if (ev && this.props.onChange) {\n        this.props.onChange(ev, newColor);\n\n        if (ev.defaultPrevented) {\n          return;\n        }\n      }\n\n      this.setState({\n        color: newColor,\n        editingColor: undefined\n      });\n    }\n  };\n\n  ColorPickerBase.defaultProps = {\n    alphaType: 'alpha',\n    strings: {\n      rootAriaLabelFormat: 'Color picker, {0} selected.',\n      hex: 'Hex',\n      red: 'Red',\n      green: 'Green',\n      blue: 'Blue',\n      alpha: 'Alpha',\n      transparency: 'Transparency',\n      hueAriaLabel: 'Hue',\n      svAriaLabel: ColorRectangleBase.defaultProps.ariaLabel,\n      svAriaValueFormat: ColorRectangleBase.defaultProps.ariaValueFormat,\n      svAriaDescription: ColorRectangleBase.defaultProps.ariaDescription\n    }\n  };\n  return ColorPickerBase;\n}(React.Component);\n\nexport { ColorPickerBase };\n\nfunction _getColorFromProps(props) {\n  var color = props.color;\n  return typeof color === 'string' ? getColorFromString(color) : color;\n}","map":null,"metadata":{},"sourceType":"module"}