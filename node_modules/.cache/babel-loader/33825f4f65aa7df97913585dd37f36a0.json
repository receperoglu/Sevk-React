{"ast":null,"code":"/**\n * Determines the distance between two points.\n *\n * @public\n */\n\n/* eslint-disable deprecation/deprecation */\nexport function getDistanceBetweenPoints(point1, point2) {\n  var left1 = point1.left || point1.x || 0;\n  var top1 = point1.top || point1.y || 0;\n  var left2 = point2.left || point2.x || 0;\n  var top2 = point2.top || point2.y || 0;\n  /* eslint-enable deprecation/deprecation */\n\n  var distance = Math.sqrt(Math.pow(left1 - left2, 2) + Math.pow(top1 - top2, 2));\n  return distance;\n}\n/**\n * Produces a proportionally-scaled version of an input content size when fit to a bounding size.\n * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally\n * using either `contain` or `cover` fit behaviors.\n * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.\n * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.\n * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.\n * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.\n *\n * @param options - the options for the bounds fit operation\n */\n\nexport function fitContentToBounds(options) {\n  var contentSize = options.contentSize,\n      boundsSize = options.boundsSize,\n      _a = options.mode,\n      mode = _a === void 0 ? 'contain' : _a,\n      _b = options.maxScale,\n      maxScale = _b === void 0 ? 1 : _b;\n  var contentAspectRatio = contentSize.width / contentSize.height;\n  var boundsAspectRatio = boundsSize.width / boundsSize.height;\n  var scale;\n\n  if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {\n    scale = boundsSize.width / contentSize.width;\n  } else {\n    scale = boundsSize.height / contentSize.height;\n  }\n\n  var finalScale = Math.min(maxScale, scale);\n  return {\n    width: contentSize.width * finalScale,\n    height: contentSize.height * finalScale\n  };\n}\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\n\nexport function calculatePrecision(value) {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  var groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n\n  if (!groups) {\n    return 0;\n  }\n\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n\n  if (groups[2]) {\n    return groups[2].length;\n  }\n\n  return 0;\n}\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\n\nexport function precisionRound(value, precision, base) {\n  if (base === void 0) {\n    base = 10;\n  }\n\n  var exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}","map":null,"metadata":{},"sourceType":"module"}