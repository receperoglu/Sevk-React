{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, css, divProperties, findIndex, findScrollableParent, getNativeProps, getParent, getWindow, initializeComponentRef } from '../../Utilities';\nimport { ScrollToMode } from './List.types';\nimport { composeRenderFunction } from '../../Utilities';\nvar RESIZE_DELAY = 16;\nvar MIN_SCROLL_UPDATE_DELAY = 100;\nvar MAX_SCROLL_UPDATE_DELAY = 500;\nvar IDLE_DEBOUNCE_DELAY = 200; // The amount of time to wait before declaring that the list isn't scrolling\n\nvar DONE_SCROLLING_WAIT = 500;\nvar DEFAULT_ITEMS_PER_PAGE = 10;\nvar DEFAULT_PAGE_HEIGHT = 30;\nvar DEFAULT_RENDERED_WINDOWS_BEHIND = 2;\nvar DEFAULT_RENDERED_WINDOWS_AHEAD = 2;\nvar PAGE_KEY_PREFIX = 'page-';\nvar SPACER_KEY_PREFIX = 'spacer-';\nvar EMPTY_RECT = {\n  top: -1,\n  bottom: -1,\n  left: -1,\n  right: -1,\n  width: 0,\n  height: 0\n}; // Naming expensive measures so that they're named in profiles.\n\nvar _measurePageRect = function _measurePageRect(element) {\n  return element.getBoundingClientRect();\n};\n\nvar _measureSurfaceRect = _measurePageRect;\nvar _measureScrollRect = _measurePageRect;\n/**\n * The List renders virtualized pages of items. Each page's item count is determined by the getItemCountForPage callback\n * if provided by the caller, or 10 as default. Each page's height is determined by the getPageHeight callback if\n * provided by the caller, or by cached measurements if available, or by a running average, or a default fallback.\n *\n * The algorithm for rendering pages works like this:\n *\n * 1. Predict visible pages based on \"current measure data\" (page heights, surface position, visible window)\n * 2. If changes are necessary, apply changes (add/remove pages)\n * 3. For pages that are added, measure the page heights if we need to using getBoundingClientRect\n * 4. If measurements don't match predictions, update measure data and goto step 1 asynchronously\n *\n * Measuring too frequently can pull performance down significantly. To compensate, we cache measured values so that\n * we can avoid re-measuring during operations that should not alter heights, like scrolling.\n *\n * To optimize glass rendering performance, onShouldVirtualize can be set. When onShouldVirtualize return false,\n * List will run in fast mode (not virtualized) to render all items without any measurements to improve page load time.\n * And we start doing measurements and rendering in virtualized mode when items grows larger than this threshold.\n *\n * However, certain operations can make measure data stale. For example, resizing the list, or passing in new props,\n * or forcing an update change cause pages to shrink/grow. When these operations occur, we increment a measureVersion\n * number, which we associate with cached measurements and use to determine if a remeasure should occur.\n */\n\nvar List =\n/** @class */\nfunction (_super) {\n  __extends(List, _super);\n\n  function List(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._root = React.createRef();\n    _this._surface = React.createRef();\n    _this._pageRefs = {};\n\n    _this._getDerivedStateFromProps = function (nextProps, previousState) {\n      if (nextProps.items !== _this.props.items || nextProps.renderCount !== _this.props.renderCount || nextProps.startIndex !== _this.props.startIndex || nextProps.version !== _this.props.version) {\n        // We have received new items so we want to make sure that initially we only render a single window to\n        // fill the currently visible rect, and then later render additional windows.\n        _this._resetRequiredWindows();\n\n        _this._requiredRect = null;\n        _this._measureVersion++;\n\n        _this._invalidatePageCache();\n\n        return _this._updatePages(nextProps, previousState);\n      }\n\n      return previousState;\n    };\n\n    _this._onRenderRoot = function (props) {\n      var rootRef = props.rootRef,\n          surfaceElement = props.surfaceElement,\n          divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: rootRef\n      }, divProps), surfaceElement);\n    };\n\n    _this._onRenderSurface = function (props) {\n      var surfaceRef = props.surfaceRef,\n          pageElements = props.pageElements,\n          divProps = props.divProps;\n      return React.createElement(\"div\", __assign({\n        ref: surfaceRef\n      }, divProps), pageElements);\n    };\n\n    _this._onRenderPage = function (pageProps, defaultRender) {\n      var _a = _this.props,\n          onRenderCell = _a.onRenderCell,\n          role = _a.role;\n\n      var _b = pageProps.page,\n          _c = _b.items,\n          items = _c === void 0 ? [] : _c,\n          startIndex = _b.startIndex,\n          divProps = __rest(pageProps, [\"page\"]); // only assign list item role if no role is assigned\n\n\n      var cellRole = role === undefined ? 'listitem' : 'presentation';\n      var cells = [];\n\n      for (var i = 0; i < items.length; i++) {\n        var index = startIndex + i;\n        var item = items[i];\n        var itemKey = _this.props.getKey ? _this.props.getKey(item, index) : item && item.key;\n\n        if (itemKey === null || itemKey === undefined) {\n          itemKey = index;\n        }\n\n        cells.push(React.createElement(\"div\", {\n          role: cellRole,\n          className: 'ms-List-cell',\n          key: itemKey,\n          \"data-list-index\": index,\n          \"data-automationid\": \"ListCell\"\n        }, onRenderCell && onRenderCell(item, index, !_this.props.ignoreScrollingState ? _this.state.isScrolling : undefined)));\n      }\n\n      return React.createElement(\"div\", __assign({}, divProps), cells);\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      pages: [],\n      isScrolling: false,\n      getDerivedStateFromProps: _this._getDerivedStateFromProps\n    };\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    _this._estimatedPageHeight = 0;\n    _this._totalEstimates = 0;\n    _this._requiredWindowsAhead = 0;\n    _this._requiredWindowsBehind = 0; // Track the measure version for everything.\n\n    _this._measureVersion = 0; // Ensure that scrolls are lazy updated.\n\n    _this._onAsyncScroll = _this._async.debounce(_this._onAsyncScroll, MIN_SCROLL_UPDATE_DELAY, {\n      leading: false,\n      maxWait: MAX_SCROLL_UPDATE_DELAY\n    });\n    _this._onAsyncIdle = _this._async.debounce(_this._onAsyncIdle, IDLE_DEBOUNCE_DELAY, {\n      leading: false\n    });\n    _this._onAsyncResize = _this._async.debounce(_this._onAsyncResize, RESIZE_DELAY, {\n      leading: false\n    });\n    _this._onScrollingDone = _this._async.debounce(_this._onScrollingDone, DONE_SCROLLING_WAIT, {\n      leading: false\n    });\n    _this._cachedPageHeights = {};\n    _this._estimatedPageHeight = 0;\n    _this._focusedIndex = -1;\n    _this._pageCache = {};\n    return _this;\n  }\n\n  List.getDerivedStateFromProps = function (nextProps, previousState) {\n    return previousState.getDerivedStateFromProps(nextProps, previousState);\n  };\n\n  Object.defineProperty(List.prototype, \"pageRefs\", {\n    get: function get() {\n      return this._pageRefs;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Scroll to the given index. By default will bring the page the specified item is on into the view. If a callback\n   * to measure the height of an individual item is specified, will only scroll to bring the specific item into view.\n   *\n   * Note: with items of variable height and no passed in `getPageHeight` method, the list might jump after scrolling\n   * when windows before/ahead are being rendered, and the estimated height is replaced using actual elements.\n   *\n   * @param index - Index of item to scroll to\n   * @param measureItem - Optional callback to measure the height of an individual item\n   * @param scrollToMode - Optional defines where in the window the item should be positioned to when scrolling\n   */\n\n  List.prototype.scrollToIndex = function (index, measureItem, scrollToMode) {\n    if (scrollToMode === void 0) {\n      scrollToMode = ScrollToMode.auto;\n    }\n\n    var startIndex = this.props.startIndex;\n\n    var renderCount = this._getRenderCount();\n\n    var endIndex = startIndex + renderCount;\n    var allowedRect = this._allowedRect;\n    var scrollTop = 0;\n    var itemsPerPage = 1;\n\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var pageSpecification = this._getPageSpecification(itemIndex, allowedRect);\n\n      var pageHeight = pageSpecification.height;\n      itemsPerPage = pageSpecification.itemCount;\n      var requestedIndexIsInPage = itemIndex <= index && itemIndex + itemsPerPage > index;\n\n      if (requestedIndexIsInPage) {\n        // We have found the page. If the user provided a way to measure an individual item, we will try to scroll in\n        // just the given item, otherwise we'll only bring the page into view\n        if (measureItem && this._scrollElement) {\n          var scrollRect = _measureScrollRect(this._scrollElement);\n\n          var scrollWindow = {\n            top: this._scrollElement.scrollTop,\n            bottom: this._scrollElement.scrollTop + scrollRect.height\n          }; // Adjust for actual item position within page\n\n          var itemPositionWithinPage = index - itemIndex;\n\n          for (var itemIndexInPage = 0; itemIndexInPage < itemPositionWithinPage; ++itemIndexInPage) {\n            scrollTop += measureItem(itemIndex + itemIndexInPage);\n          }\n\n          var scrollBottom = scrollTop + measureItem(index); // If scrollToMode is set to something other than auto, we always want to\n          // scroll the item into a specific position on the page.\n\n          switch (scrollToMode) {\n            case ScrollToMode.top:\n              this._scrollElement.scrollTop = scrollTop;\n              return;\n\n            case ScrollToMode.bottom:\n              this._scrollElement.scrollTop = scrollBottom - scrollRect.height;\n              return;\n\n            case ScrollToMode.center:\n              this._scrollElement.scrollTop = (scrollTop + scrollBottom - scrollRect.height) / 2;\n              return;\n\n            case ScrollToMode.auto:\n            default:\n              break;\n          }\n\n          var itemIsFullyVisible = scrollTop >= scrollWindow.top && scrollBottom <= scrollWindow.bottom;\n\n          if (itemIsFullyVisible) {\n            // Item is already visible, do nothing.\n            return;\n          }\n\n          var itemIsPartiallyAbove = scrollTop < scrollWindow.top;\n          var itemIsPartiallyBelow = scrollBottom > scrollWindow.bottom;\n\n          if (itemIsPartiallyAbove) {//  We will just scroll to 'scrollTop'\n            //  .------.   - scrollTop\n            //  |Item  |\n            //  | .----|-. - scrollWindow.top\n            //  '------' |\n            //    |      |\n            //    '------'\n          } else if (itemIsPartiallyBelow) {\n            //  Adjust scrollTop position to just bring in the element\n            // .------.  - scrollTop\n            // |      |\n            // | .------.\n            // '-|----' | - scrollWindow.bottom\n            //   | Item |\n            //   '------' - scrollBottom\n            scrollTop = scrollBottom - scrollRect.height;\n          }\n        }\n\n        this._scrollElement.scrollTop = scrollTop;\n        return;\n      }\n\n      scrollTop += pageHeight;\n    }\n  };\n\n  List.prototype.getStartItemIndexInView = function (measureItem) {\n    var pages = this.state.pages || [];\n\n    for (var _i = 0, pages_1 = pages; _i < pages_1.length; _i++) {\n      var page = pages_1[_i];\n      var isPageVisible = !page.isSpacer && (this._scrollTop || 0) >= page.top && (this._scrollTop || 0) <= page.top + page.height;\n\n      if (isPageVisible) {\n        if (!measureItem) {\n          var rowHeight = Math.floor(page.height / page.itemCount);\n          return page.startIndex + Math.floor((this._scrollTop - page.top) / rowHeight);\n        } else {\n          var totalRowHeight = 0;\n\n          for (var itemIndex = page.startIndex; itemIndex < page.startIndex + page.itemCount; itemIndex++) {\n            var rowHeight = measureItem(itemIndex);\n\n            if (page.top + totalRowHeight <= this._scrollTop && this._scrollTop < page.top + totalRowHeight + rowHeight) {\n              return itemIndex;\n            } else {\n              totalRowHeight += rowHeight;\n            }\n          }\n        }\n      }\n    }\n\n    return 0;\n  };\n\n  List.prototype.componentDidMount = function () {\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n    this._scrollElement = findScrollableParent(this._root.current);\n\n    this._events.on(window, 'resize', this._onAsyncResize);\n\n    if (this._root.current) {\n      this._events.on(this._root.current, 'focus', this._onFocus, true);\n    }\n\n    if (this._scrollElement) {\n      this._events.on(this._scrollElement, 'scroll', this._onScroll);\n\n      this._events.on(this._scrollElement, 'scroll', this._onAsyncScroll);\n    }\n  };\n\n  List.prototype.componentDidUpdate = function (previousProps, previousState) {\n    var finalProps = this.props;\n    var finalState = this.state;\n\n    if (this.state.pagesVersion !== previousState.pagesVersion) {\n      // If we weren't provided with the page height, measure the pages\n      if (!finalProps.getPageHeight) {\n        // If measured version is invalid since we've updated the DOM\n        var heightsChanged = this._updatePageMeasurements(finalState.pages); // On first render, we should re-measure so that we don't get a visual glitch.\n\n\n        if (heightsChanged) {\n          this._materializedRect = null;\n\n          if (!this._hasCompletedFirstRender) {\n            this._hasCompletedFirstRender = true;\n            this.setState(this._updatePages(finalProps, finalState));\n          } else {\n            this._onAsyncScroll();\n          }\n        } else {\n          // Enqueue an idle bump.\n          this._onAsyncIdle();\n        }\n      } else {\n        // Enqueue an idle bump\n        this._onAsyncIdle();\n      } // Notify the caller that rendering the new pages has completed\n\n\n      if (finalProps.onPagesUpdated) {\n        finalProps.onPagesUpdated(finalState.pages);\n      }\n    }\n  };\n\n  List.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n\n    delete this._scrollElement;\n  };\n\n  List.prototype.shouldComponentUpdate = function (newProps, newState) {\n    var oldPages = this.state.pages;\n    var newPages = newState.pages;\n    var shouldComponentUpdate = false; // Update if the page stops scrolling\n\n    if (!newState.isScrolling && this.state.isScrolling) {\n      return true;\n    }\n\n    if (newProps.version !== this.props.version) {\n      return true;\n    }\n\n    if (newProps.items === this.props.items && oldPages.length === newPages.length) {\n      for (var i = 0; i < oldPages.length; i++) {\n        var oldPage = oldPages[i];\n        var newPage = newPages[i];\n\n        if (oldPage.key !== newPage.key || oldPage.itemCount !== newPage.itemCount) {\n          shouldComponentUpdate = true;\n          break;\n        }\n      }\n    } else {\n      shouldComponentUpdate = true;\n    }\n\n    return shouldComponentUpdate;\n  };\n\n  List.prototype.forceUpdate = function () {\n    this._invalidatePageCache(); // Ensure that when the list is force updated we update the pages first before render.\n\n\n    this._updateRenderRects(this.props, this.state, true);\n\n    this.setState(this._updatePages(this.props, this.state));\n    this._measureVersion++;\n\n    _super.prototype.forceUpdate.call(this);\n  };\n  /**\n   * Get the current height the list and it's pages.\n   */\n\n\n  List.prototype.getTotalListHeight = function () {\n    return this._surfaceRect.height;\n  };\n\n  List.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        _b = _a.role,\n        role = _b === void 0 ? 'list' : _b,\n        onRenderSurface = _a.onRenderSurface,\n        onRenderRoot = _a.onRenderRoot;\n    var _c = this.state.pages,\n        pages = _c === void 0 ? [] : _c;\n    var pageElements = [];\n    var divProps = getNativeProps(this.props, divProperties);\n\n    for (var _i = 0, pages_2 = pages; _i < pages_2.length; _i++) {\n      var page = pages_2[_i];\n      pageElements.push(this._renderPage(page));\n    }\n\n    var finalOnRenderSurface = onRenderSurface ? composeRenderFunction(onRenderSurface, this._onRenderSurface) : this._onRenderSurface;\n    var finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, this._onRenderRoot) : this._onRenderRoot;\n    return finalOnRenderRoot({\n      rootRef: this._root,\n      pages: pages,\n      surfaceElement: finalOnRenderSurface({\n        surfaceRef: this._surface,\n        pages: pages,\n        pageElements: pageElements,\n        divProps: {\n          role: 'presentation',\n          className: 'ms-List-surface'\n        }\n      }),\n      divProps: __assign(__assign({}, divProps), {\n        className: css('ms-List', className),\n        role: pageElements.length > 0 ? role : undefined\n      })\n    });\n  };\n\n  List.prototype._shouldVirtualize = function (props) {\n    if (props === void 0) {\n      props = this.props;\n    }\n\n    var onShouldVirtualize = props.onShouldVirtualize;\n    return !onShouldVirtualize || onShouldVirtualize(props);\n  };\n  /**\n   * when props.items change or forceUpdate called, throw away cached pages\n   */\n\n\n  List.prototype._invalidatePageCache = function () {\n    this._pageCache = {};\n  };\n\n  List.prototype._renderPage = function (page) {\n    var _this = this;\n\n    var usePageCache = this.props.usePageCache;\n    var cachedPage; // if usePageCache is set and cached page element can be found, just return cached page\n\n    if (usePageCache) {\n      cachedPage = this._pageCache[page.key];\n\n      if (cachedPage && cachedPage.pageElement) {\n        return cachedPage.pageElement;\n      }\n    }\n\n    var pageStyle = this._getPageStyle(page);\n\n    var _a = this.props.onRenderPage,\n        onRenderPage = _a === void 0 ? this._onRenderPage : _a;\n    var pageElement = onRenderPage({\n      page: page,\n      className: 'ms-List-page',\n      key: page.key,\n      ref: function ref(newRef) {\n        _this._pageRefs[page.key] = newRef;\n      },\n      style: pageStyle,\n      role: 'presentation'\n    }, this._onRenderPage); // cache the first page for now since it is re-rendered a lot times unnecessarily.\n    // todo: a more aggresive caching mechanism is to cache pages constaining the items not changed.\n    // now we re-render pages too frequently, for example, props.items increased from 30 to 60, although the\n    // first 30 items did not change, we still re-rendered all of them in this props.items change.\n\n    if (usePageCache && page.startIndex === 0) {\n      this._pageCache[page.key] = {\n        page: page,\n        pageElement: pageElement\n      };\n    }\n\n    return pageElement;\n  };\n  /** Generate the style object for the page. */\n\n\n  List.prototype._getPageStyle = function (page) {\n    var getPageStyle = this.props.getPageStyle;\n    return __assign(__assign({}, getPageStyle ? getPageStyle(page) : {}), !page.items ? {\n      height: page.height\n    } : {});\n  };\n  /** Track the last item index focused so that we ensure we keep it rendered. */\n\n\n  List.prototype._onFocus = function (ev) {\n    var target = ev.target;\n\n    while (target !== this._surface.current) {\n      var indexString = target.getAttribute('data-list-index');\n\n      if (indexString) {\n        this._focusedIndex = Number(indexString);\n        break;\n      }\n\n      target = getParent(target);\n    }\n  };\n  /**\n   * Called synchronously to reset the required render range to 0 on scrolling. After async scroll has executed,\n   * we will call onAsyncIdle which will reset it back to it's correct value.\n   */\n\n\n  List.prototype._onScroll = function () {\n    if (!this.state.isScrolling && !this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: true\n      });\n    }\n\n    this._resetRequiredWindows();\n\n    this._onScrollingDone();\n  };\n\n  List.prototype._resetRequiredWindows = function () {\n    this._requiredWindowsAhead = 0;\n    this._requiredWindowsBehind = 0;\n  };\n  /**\n   * Debounced method to asynchronously update the visible region on a scroll event.\n   */\n\n\n  List.prototype._onAsyncScroll = function () {\n    this._updateRenderRects(this.props, this.state); // Only update pages when the visible rect falls outside of the materialized rect.\n\n\n    if (!this._materializedRect || !_isContainedWithin(this._requiredRect, this._materializedRect)) {\n      this.setState(this._updatePages(this.props, this.state));\n    } else {// console.log('requiredRect contained in materialized', this._requiredRect, this._materializedRect);\n    }\n  };\n  /**\n   * This is an async debounced method that will try and increment the windows we render. If we can increment\n   * either, we increase the amount we render and re-evaluate.\n   */\n\n\n  List.prototype._onAsyncIdle = function () {\n    var _a = this.props,\n        renderedWindowsAhead = _a.renderedWindowsAhead,\n        renderedWindowsBehind = _a.renderedWindowsBehind;\n\n    var _b = this,\n        requiredWindowsAhead = _b._requiredWindowsAhead,\n        requiredWindowsBehind = _b._requiredWindowsBehind;\n\n    var windowsAhead = Math.min(renderedWindowsAhead, requiredWindowsAhead + 1);\n    var windowsBehind = Math.min(renderedWindowsBehind, requiredWindowsBehind + 1);\n\n    if (windowsAhead !== requiredWindowsAhead || windowsBehind !== requiredWindowsBehind) {\n      // console.log('idling', windowsBehind, windowsAhead);\n      this._requiredWindowsAhead = windowsAhead;\n      this._requiredWindowsBehind = windowsBehind;\n\n      this._updateRenderRects(this.props, this.state);\n\n      this.setState(this._updatePages(this.props, this.state));\n    }\n\n    if (renderedWindowsAhead > windowsAhead || renderedWindowsBehind > windowsBehind) {\n      // Async increment on next tick.\n      this._onAsyncIdle();\n    }\n  };\n  /**\n   * Function to call when the list is done scrolling.\n   * This function is debounced.\n   */\n\n\n  List.prototype._onScrollingDone = function () {\n    if (!this.props.ignoreScrollingState) {\n      this.setState({\n        isScrolling: false\n      });\n    }\n  };\n\n  List.prototype._onAsyncResize = function () {\n    this.forceUpdate();\n  };\n\n  List.prototype._updatePages = function (nextProps, previousState) {\n    // console.log('updating pages');\n    if (!this._requiredRect) {\n      this._updateRenderRects(nextProps, previousState);\n    }\n\n    var newListState = this._buildPages(nextProps, previousState);\n\n    var oldListPages = previousState.pages;\n\n    this._notifyPageChanges(oldListPages, newListState.pages, this.props);\n\n    return __assign(__assign(__assign({}, previousState), newListState), {\n      pagesVersion: {}\n    });\n  };\n  /**\n   * Notify consumers that the rendered pages have changed\n   * @param oldPages - The old pages\n   * @param newPages - The new pages\n   * @param props - The props to use\n   */\n\n\n  List.prototype._notifyPageChanges = function (oldPages, newPages, props) {\n    var onPageAdded = props.onPageAdded,\n        onPageRemoved = props.onPageRemoved;\n\n    if (onPageAdded || onPageRemoved) {\n      var renderedIndexes = {};\n\n      for (var _i = 0, oldPages_1 = oldPages; _i < oldPages_1.length; _i++) {\n        var page = oldPages_1[_i];\n\n        if (page.items) {\n          renderedIndexes[page.startIndex] = page;\n        }\n      }\n\n      for (var _a = 0, newPages_1 = newPages; _a < newPages_1.length; _a++) {\n        var page = newPages_1[_a];\n\n        if (page.items) {\n          if (!renderedIndexes[page.startIndex]) {\n            this._onPageAdded(page);\n          } else {\n            delete renderedIndexes[page.startIndex];\n          }\n        }\n      }\n\n      for (var index in renderedIndexes) {\n        if (renderedIndexes.hasOwnProperty(index)) {\n          this._onPageRemoved(renderedIndexes[index]);\n        }\n      }\n    }\n  };\n\n  List.prototype._updatePageMeasurements = function (pages) {\n    var heightChanged = false; // when not in virtualize mode, we render all the items without page measurement\n\n    if (!this._shouldVirtualize()) {\n      return heightChanged;\n    }\n\n    for (var i = 0; i < pages.length; i++) {\n      var page = pages[i];\n\n      if (page.items) {\n        heightChanged = this._measurePage(page) || heightChanged;\n      }\n    }\n\n    return heightChanged;\n  };\n  /**\n   * Given a page, measure its dimensions, update cache.\n   * @returns True if the height has changed.\n   */\n\n\n  List.prototype._measurePage = function (page) {\n    var hasChangedHeight = false;\n    var pageElement = this._pageRefs[page.key];\n    var cachedHeight = this._cachedPageHeights[page.startIndex]; // console.log('   * measure attempt', page.startIndex, cachedHeight);\n\n    if (pageElement && this._shouldVirtualize() && (!cachedHeight || cachedHeight.measureVersion !== this._measureVersion)) {\n      var newClientRect = {\n        width: pageElement.clientWidth,\n        height: pageElement.clientHeight\n      };\n\n      if (newClientRect.height || newClientRect.width) {\n        hasChangedHeight = page.height !== newClientRect.height; // console.warn(' *** expensive page measure', page.startIndex, page.height, newClientRect.height);\n\n        page.height = newClientRect.height;\n        this._cachedPageHeights[page.startIndex] = {\n          height: newClientRect.height,\n          measureVersion: this._measureVersion\n        };\n        this._estimatedPageHeight = Math.round((this._estimatedPageHeight * this._totalEstimates + newClientRect.height) / (this._totalEstimates + 1));\n        this._totalEstimates++;\n      }\n    }\n\n    return hasChangedHeight;\n  };\n  /** Called when a page has been added to the DOM. */\n\n\n  List.prototype._onPageAdded = function (page) {\n    var onPageAdded = this.props.onPageAdded; // console.log('page added', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageAdded) {\n      onPageAdded(page);\n    }\n  };\n  /** Called when a page has been removed from the DOM. */\n\n\n  List.prototype._onPageRemoved = function (page) {\n    var onPageRemoved = this.props.onPageRemoved; // console.log('  --- page removed', page.startIndex, this.state.pages.map(page => page.key).join(', '));\n\n    if (onPageRemoved) {\n      onPageRemoved(page);\n    }\n  };\n  /** Build up the pages that should be rendered. */\n\n\n  List.prototype._buildPages = function (props, state) {\n    var renderCount = props.renderCount;\n    var items = props.items,\n        startIndex = props.startIndex,\n        getPageHeight = props.getPageHeight;\n    renderCount = this._getRenderCount(props);\n\n    var materializedRect = __assign({}, EMPTY_RECT);\n\n    var pages = [];\n    var itemsPerPage = 1;\n    var pageTop = 0;\n    var currentSpacer = null;\n    var focusedIndex = this._focusedIndex;\n    var endIndex = startIndex + renderCount;\n\n    var shouldVirtualize = this._shouldVirtualize(props); // First render is very important to track; when we render cells, we have no idea of estimated page height.\n    // So we should default to rendering only the first page so that we can get information.\n    // However if the user provides a measure function, let's just assume they know the right heights.\n\n\n    var isFirstRender = this._estimatedPageHeight === 0 && !getPageHeight;\n    var allowedRect = this._allowedRect;\n\n    var _loop_1 = function _loop_1(itemIndex) {\n      var pageSpecification = this_1._getPageSpecification(itemIndex, allowedRect);\n\n      var pageHeight = pageSpecification.height;\n      var pageData = pageSpecification.data;\n      var key = pageSpecification.key;\n      itemsPerPage = pageSpecification.itemCount;\n      var pageBottom = pageTop + pageHeight - 1;\n      var isPageRendered = findIndex(state.pages, function (page) {\n        return !!page.items && page.startIndex === itemIndex;\n      }) > -1;\n      var isPageInAllowedRange = !allowedRect || pageBottom >= allowedRect.top && pageTop <= allowedRect.bottom;\n      var isPageInRequiredRange = !this_1._requiredRect || pageBottom >= this_1._requiredRect.top && pageTop <= this_1._requiredRect.bottom;\n      var isPageVisible = !isFirstRender && (isPageInRequiredRange || isPageInAllowedRange && isPageRendered) || !shouldVirtualize;\n      var isPageFocused = focusedIndex >= itemIndex && focusedIndex < itemIndex + itemsPerPage;\n      var isFirstPage = itemIndex === startIndex; // console.log('building page', itemIndex, 'pageTop: ' + pageTop, 'inAllowed: ' +\n      // isPageInAllowedRange, 'inRequired: ' + isPageInRequiredRange);\n      // Only render whats visible, focused, or first page,\n      // or when running in fast rendering mode (not in virtualized mode), we render all current items in pages\n\n      if (isPageVisible || isPageFocused || isFirstPage) {\n        if (currentSpacer) {\n          pages.push(currentSpacer);\n          currentSpacer = null;\n        }\n\n        var itemsInPage = Math.min(itemsPerPage, endIndex - itemIndex);\n\n        var newPage = this_1._createPage(key, items.slice(itemIndex, itemIndex + itemsInPage), itemIndex, undefined, undefined, pageData);\n\n        newPage.top = pageTop;\n        newPage.height = pageHeight;\n\n        if (this_1._visibleRect && this_1._visibleRect.bottom) {\n          newPage.isVisible = pageBottom >= this_1._visibleRect.top && pageTop <= this_1._visibleRect.bottom;\n        }\n\n        pages.push(newPage);\n\n        if (isPageInRequiredRange && this_1._allowedRect) {\n          _mergeRect(materializedRect, {\n            top: pageTop,\n            bottom: pageBottom,\n            height: pageHeight,\n            left: allowedRect.left,\n            right: allowedRect.right,\n            width: allowedRect.width\n          });\n        }\n      } else {\n        if (!currentSpacer) {\n          currentSpacer = this_1._createPage(SPACER_KEY_PREFIX + itemIndex, undefined, itemIndex, 0, undefined, pageData, true\n          /*isSpacer*/\n          );\n        }\n\n        currentSpacer.height = (currentSpacer.height || 0) + (pageBottom - pageTop) + 1;\n        currentSpacer.itemCount += itemsPerPage;\n      }\n\n      pageTop += pageBottom - pageTop + 1; // in virtualized mode, we render need to render first page then break and measure,\n      // otherwise, we render all items without measurement to make rendering fast\n\n      if (isFirstRender && shouldVirtualize) {\n        return \"break\";\n      }\n    };\n\n    var this_1 = this;\n\n    for (var itemIndex = startIndex; itemIndex < endIndex; itemIndex += itemsPerPage) {\n      var state_1 = _loop_1(itemIndex);\n\n      if (state_1 === \"break\") break;\n    }\n\n    if (currentSpacer) {\n      currentSpacer.key = SPACER_KEY_PREFIX + 'end';\n      pages.push(currentSpacer);\n    }\n\n    this._materializedRect = materializedRect; // console.log('materialized: ', materializedRect);\n\n    return __assign(__assign({}, state), {\n      pages: pages,\n      measureVersion: this._measureVersion\n    });\n  };\n\n  List.prototype._getPageSpecification = function (itemIndex, visibleRect) {\n    var getPageSpecification = this.props.getPageSpecification;\n\n    if (getPageSpecification) {\n      var pageData = getPageSpecification(itemIndex, visibleRect);\n      var _a = pageData.itemCount,\n          itemCount = _a === void 0 ? this._getItemCountForPage(itemIndex, visibleRect) : _a;\n      var _b = pageData.height,\n          height = _b === void 0 ? this._getPageHeight(itemIndex, visibleRect, itemCount) : _b;\n      return {\n        itemCount: itemCount,\n        height: height,\n        data: pageData.data,\n        key: pageData.key\n      };\n    } else {\n      var itemCount = this._getItemCountForPage(itemIndex, visibleRect);\n\n      return {\n        itemCount: itemCount,\n        height: this._getPageHeight(itemIndex, visibleRect, itemCount)\n      };\n    }\n  };\n  /**\n   * Get the pixel height of a give page. Will use the props getPageHeight first, and if not provided, fallback to\n   * cached height, or estimated page height, or default page height.\n   */\n\n\n  List.prototype._getPageHeight = function (itemIndex, visibleRect, itemsPerPage) {\n    if (this.props.getPageHeight) {\n      return this.props.getPageHeight(itemIndex, visibleRect, itemsPerPage);\n    } else {\n      var cachedHeight = this._cachedPageHeights[itemIndex];\n      return cachedHeight ? cachedHeight.height : this._estimatedPageHeight || DEFAULT_PAGE_HEIGHT;\n    }\n  };\n\n  List.prototype._getItemCountForPage = function (itemIndex, visibileRect) {\n    var itemsPerPage = this.props.getItemCountForPage ? this.props.getItemCountForPage(itemIndex, visibileRect) : DEFAULT_ITEMS_PER_PAGE;\n    return itemsPerPage ? itemsPerPage : DEFAULT_ITEMS_PER_PAGE;\n  };\n\n  List.prototype._createPage = function (pageKey, items, startIndex, count, style, data, isSpacer) {\n    if (startIndex === void 0) {\n      startIndex = -1;\n    }\n\n    if (count === void 0) {\n      count = items ? items.length : 0;\n    }\n\n    if (style === void 0) {\n      style = {};\n    }\n\n    pageKey = pageKey || PAGE_KEY_PREFIX + startIndex;\n    var cachedPage = this._pageCache[pageKey];\n\n    if (cachedPage && cachedPage.page) {\n      return cachedPage.page;\n    }\n\n    return {\n      key: pageKey,\n      startIndex: startIndex,\n      itemCount: count,\n      items: items,\n      style: style,\n      top: 0,\n      height: 0,\n      data: data,\n      isSpacer: isSpacer || false\n    };\n  };\n\n  List.prototype._getRenderCount = function (props) {\n    var _a = props || this.props,\n        items = _a.items,\n        startIndex = _a.startIndex,\n        renderCount = _a.renderCount;\n\n    return renderCount === undefined ? items ? items.length - startIndex : 0 : renderCount;\n  };\n  /** Calculate the visible rect within the list where top: 0 and left: 0 is the top/left of the list. */\n\n\n  List.prototype._updateRenderRects = function (props, state, forceUpdate) {\n    var renderedWindowsAhead = props.renderedWindowsAhead,\n        renderedWindowsBehind = props.renderedWindowsBehind;\n    var pages = state.pages; // when not in virtualize mode, we render all items without measurement to optimize page rendering perf\n\n    if (!this._shouldVirtualize(props)) {\n      return;\n    }\n\n    var surfaceRect = this._surfaceRect || __assign({}, EMPTY_RECT);\n\n    var scrollHeight = this._scrollElement && this._scrollElement.scrollHeight;\n    var scrollTop = this._scrollElement ? this._scrollElement.scrollTop : 0; // WARNING: EXPENSIVE CALL! We need to know the surface top relative to the window.\n    // This needs to be called to recalculate when new pages should be loaded.\n    // We check to see how far we've scrolled and if it's further than a third of a page we run it again.\n\n    if (this._surface.current && (forceUpdate || !pages || !this._surfaceRect || !scrollHeight || scrollHeight !== this._scrollHeight || Math.abs(this._scrollTop - scrollTop) > this._estimatedPageHeight / 3)) {\n      surfaceRect = this._surfaceRect = _measureSurfaceRect(this._surface.current);\n      this._scrollTop = scrollTop;\n    } // If the scroll height has changed, something in the container likely resized and\n    // we should redo the page heights incase their content resized.\n\n\n    if (forceUpdate || !scrollHeight || scrollHeight !== this._scrollHeight) {\n      this._measureVersion++;\n    }\n\n    this._scrollHeight = scrollHeight; // If the surface is above the container top or below the container bottom, or if this is not the first\n    // render return empty rect.\n    // The first time the list gets rendered we need to calculate the rectangle. The width of the list is\n    // used to calculate the width of the list items.\n\n    var visibleTop = Math.max(0, -surfaceRect.top);\n    var win = getWindow(this._root.current);\n    var visibleRect = {\n      top: visibleTop,\n      left: surfaceRect.left,\n      bottom: visibleTop + win.innerHeight,\n      right: surfaceRect.right,\n      width: surfaceRect.width,\n      height: win.innerHeight\n    }; // The required/allowed rects are adjusted versions of the visible rect.\n\n    this._requiredRect = _expandRect(visibleRect, this._requiredWindowsBehind, this._requiredWindowsAhead);\n    this._allowedRect = _expandRect(visibleRect, renderedWindowsBehind, renderedWindowsAhead); // store the visible rect for later use.\n\n    this._visibleRect = visibleRect;\n  };\n\n  List.defaultProps = {\n    startIndex: 0,\n    onRenderCell: function onRenderCell(item, index, containsFocus) {\n      return React.createElement(React.Fragment, null, item && item.name || '');\n    },\n    renderedWindowsAhead: DEFAULT_RENDERED_WINDOWS_AHEAD,\n    renderedWindowsBehind: DEFAULT_RENDERED_WINDOWS_BEHIND\n  };\n  return List;\n}(React.Component);\n\nexport { List };\n\nfunction _expandRect(rect, pagesBefore, pagesAfter) {\n  var top = rect.top - pagesBefore * rect.height;\n  var height = rect.height + (pagesBefore + pagesAfter) * rect.height;\n  return {\n    top: top,\n    bottom: top + height,\n    height: height,\n    left: rect.left,\n    right: rect.right,\n    width: rect.width\n  };\n}\n\nfunction _isContainedWithin(innerRect, outerRect) {\n  return innerRect.top >= outerRect.top && innerRect.left >= outerRect.left && innerRect.bottom <= outerRect.bottom && innerRect.right <= outerRect.right;\n}\n\nfunction _mergeRect(targetRect, newRect) {\n  targetRect.top = newRect.top < targetRect.top || targetRect.top === -1 ? newRect.top : targetRect.top;\n  targetRect.left = newRect.left < targetRect.left || targetRect.left === -1 ? newRect.left : targetRect.left;\n  targetRect.bottom = newRect.bottom > targetRect.bottom || targetRect.bottom === -1 ? newRect.bottom : targetRect.bottom;\n  targetRect.right = newRect.right > targetRect.right || targetRect.right === -1 ? newRect.right : targetRect.right;\n  targetRect.width = targetRect.right - targetRect.left + 1;\n  targetRect.height = targetRect.bottom - targetRect.top + 1;\n  return targetRect;\n}","map":null,"metadata":{},"sourceType":"module"}