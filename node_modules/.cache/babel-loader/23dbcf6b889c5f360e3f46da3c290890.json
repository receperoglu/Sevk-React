{"ast":null,"code":"import * as React from 'react';\n/**\n * Controlled state helper that gives priority to props value. Useful for components that have props with both\n * controlled and uncontrolled modes. Any props values will override state, but will not update internal state.\n * If prop is defined and then later undefined, state will revert to its previous value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param options - Options. defaultPropValue is only used if defaultPropName (or its value) is undefined.\n */\n\nexport function useControlledState(props, propName, options) {\n  var defaultValue;\n\n  if (options) {\n    if (options.defaultPropName && props[options.defaultPropName] !== undefined) {\n      // No easy way to coerce TProps[TDefaultProp] to match TProps[TProp] in generic typings, so cast it here.\n      defaultValue = props[options.defaultPropName];\n    } else {\n      defaultValue = options && options.defaultPropValue;\n    }\n  }\n\n  var _a = React.useState(defaultValue),\n      state = _a[0],\n      setState = _a[1];\n\n  if (props[propName] !== undefined) {\n    return [props[propName], setState];\n  } else {\n    return [state, setState];\n  }\n}\n/**\n * Simple controlled helper that gives priority to props value and falls back to derived value.\n *\n * @param props - The props object containing controlled prop values.\n * @param propName - The controlled prop name.\n * @param derivedValue - Derived value. Returned when controlled value is not present.\n */\n\nexport function getControlledDerivedProps(props, propName, derivedValue) {\n  if (props[propName] !== undefined) {\n    return props[propName];\n  } else {\n    return derivedValue;\n  }\n}","map":null,"metadata":{},"sourceType":"module"}