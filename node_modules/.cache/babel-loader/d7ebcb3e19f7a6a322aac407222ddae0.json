{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { warnDeprecations, initializeComponentRef, classNamesFunction, css, format, getId, divProperties, getNativeProps } from '../../Utilities';\nimport { Icon } from '../../Icon';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { RatingSize } from './Rating.types';\nvar getClassNames = classNamesFunction();\n\nvar RatingStar = function RatingStar(props) {\n  var icon = props.icon || 'FavoriteStarFill';\n  return React.createElement(\"div\", {\n    className: props.classNames.ratingStar,\n    key: props.id\n  }, React.createElement(Icon, {\n    className: props.classNames.ratingStarBack,\n    iconName: icon\n  }), !props.disabled && React.createElement(Icon, {\n    className: props.classNames.ratingStarFront,\n    iconName: icon,\n    style: {\n      width: props.fillPercentage + '%'\n    }\n  }));\n};\n\nvar RatingBase =\n/** @class */\nfunction (_super) {\n  __extends(RatingBase, _super);\n\n  function RatingBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    initializeComponentRef(_this);\n    warnDeprecations('Rating', props, {\n      onChanged: 'onChange'\n    });\n    _this._id = getId('Rating');\n    _this._min = _this.props.allowZeroStars ? 0 : 1;\n    /* eslint-disable deprecation/deprecation */\n\n    if (_this.props.min !== undefined && _this.props.min !== 1) {\n      _this._min = _this.props.min;\n    }\n    /* eslint-enable deprecation/deprecation */\n\n\n    _this._labelId = getId('RatingLabel');\n    _this.state = {\n      rating: _this._getInitialValue(props)\n    };\n    return _this;\n  }\n\n  RatingBase.prototype.render = function () {\n    var _a, _b, _c;\n\n    var _d = this.props,\n        disabled = _d.disabled,\n        getAriaLabel = _d.getAriaLabel,\n        styles = _d.styles,\n        max = _d.max,\n        readOnly = _d.readOnly,\n        size = _d.size,\n        theme = _d.theme,\n        _e = _d.icon,\n        icon = _e === void 0 ? 'FavoriteStarFill' : _e,\n        _f = _d.unselectedIcon,\n        unselectedIcon = _f === void 0 ? 'FavoriteStar' : _f;\n    var id = this._id;\n    var stars = [];\n    var starIds = [];\n\n    var rating = this._getRating();\n\n    var divProps = getNativeProps(this.props, divProperties);\n    this._classNames = getClassNames(styles, {\n      disabled: disabled,\n      readOnly: readOnly,\n      theme: theme\n    });\n\n    for (var i = this._min; i <= max; i++) {\n      if (i !== 0) {\n        var fillPercentage = this._getFillingPercentage(i);\n\n        var ratingStarProps = {\n          fillPercentage: fillPercentage,\n          disabled: disabled,\n          classNames: this._classNames,\n          icon: fillPercentage > 0 ? icon : unselectedIcon\n        };\n        starIds.push(this._getStarId(i - 1));\n        stars.push(React.createElement(\"button\", __assign({\n          className: css(this._classNames.ratingButton, (_a = {}, _a[this._classNames.ratingStarIsLarge] = size === RatingSize.Large, _a[this._classNames.ratingStarIsSmall] = size !== RatingSize.Large, _a)),\n          id: starIds[i - 1],\n          key: i\n        }, i === Math.ceil(rating) ? {\n          'data-is-current': true\n        } : {}, {\n          onFocus: this._onFocus.bind(this, i),\n          onClick: this._onFocus.bind(this, i),\n          disabled: disabled || readOnly ? true : false,\n          role: \"presentation\",\n          type: \"button\"\n        }), this._getLabel(i), React.createElement(RatingStar, __assign({\n          key: i + 'rating'\n        }, ratingStarProps))));\n      }\n    }\n\n    var ariaLabel = getAriaLabel ? getAriaLabel(rating ? rating : 0, max) : undefined; // When in read-only mode, we allow focus (per ARIA standards) and set up ARIA attributes to indicate element\n    // is read-only. https://www.w3.org/TR/wai-aria-1.1/#aria-readonly\n\n    var readOnlyProps = readOnly ? {\n      allowFocusRoot: true,\n      disabled: true,\n      'aria-label': ariaLabel,\n      'aria-readonly': true,\n      'data-is-focusable': true,\n      tabIndex: 0\n    } : undefined;\n    return React.createElement(\"div\", __assign({\n      className: css('ms-Rating-star', this._classNames.root, (_b = {}, _b[this._classNames.rootIsLarge] = size === RatingSize.Large, _b[this._classNames.rootIsSmall] = size !== RatingSize.Large, _b)),\n      \"aria-label\": !readOnly ? ariaLabel : '',\n      id: id\n    }, divProps), React.createElement(FocusZone, __assign({\n      direction: FocusZoneDirection.horizontal,\n      className: css(this._classNames.ratingFocusZone, (_c = {}, _c[this._classNames.rootIsLarge] = size === RatingSize.Large, _c[this._classNames.rootIsSmall] = size !== RatingSize.Large, _c)),\n      defaultActiveElement: rating ? starIds[Math.ceil(rating) - 1] && '#' + starIds[Math.ceil(rating) - 1] : undefined\n    }, readOnlyProps), stars));\n  };\n\n  RatingBase.prototype._getStarId = function (index) {\n    return this._id + '-star-' + index;\n  };\n\n  RatingBase.prototype._onFocus = function (value, ev) {\n    if (Math.ceil(this.state.rating) !== value) {\n      this.setState({\n        rating: value\n      }); // eslint-disable-next-line deprecation/deprecation\n\n      var _a = this.props,\n          onChange = _a.onChange,\n          onChanged = _a.onChanged;\n\n      if (onChange) {\n        onChange(ev, value);\n      }\n\n      if (onChanged) {\n        onChanged(value);\n      }\n    }\n  };\n\n  RatingBase.prototype._getLabel = function (rating) {\n    var text = this.props.ariaLabelFormat || '';\n    return React.createElement(\"span\", {\n      id: this._labelId + \"-\" + rating,\n      className: this._classNames.labelText\n    }, format(text, rating, this.props.max));\n  };\n\n  RatingBase.prototype._getInitialValue = function (props) {\n    if (typeof props.rating === 'undefined') {\n      return this._min;\n    }\n\n    if (props.rating === null) {\n      return undefined;\n    }\n\n    return this._getClampedRating(props.rating);\n  };\n\n  RatingBase.prototype._getClampedRating = function (rating) {\n    return Math.min(Math.max(rating, this._min), this.props.max);\n  };\n\n  RatingBase.prototype._getRating = function () {\n    if (this.props.rating !== undefined) {\n      return this._getClampedRating(this.props.rating);\n    }\n\n    if (this.state.rating !== undefined && this.state.rating !== null) {\n      return this._getClampedRating(this.state.rating);\n    }\n\n    return 0;\n  };\n\n  RatingBase.prototype._getFillingPercentage = function (starPosition) {\n    var rating = this._getRating();\n\n    var ceilValue = Math.ceil(rating);\n    var fillPercentage = 100;\n\n    if (starPosition === rating) {\n      fillPercentage = 100;\n    } else if (starPosition === ceilValue) {\n      fillPercentage = 100 * (rating % 1);\n    } else if (starPosition > ceilValue) {\n      fillPercentage = 0;\n    }\n\n    return fillPercentage;\n  };\n\n  RatingBase.defaultProps = {\n    min: 1,\n    max: 5\n  };\n  return RatingBase;\n}(React.Component);\n\nexport { RatingBase };","map":null,"metadata":{},"sourceType":"module"}