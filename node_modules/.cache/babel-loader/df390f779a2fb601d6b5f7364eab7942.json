{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, classNamesFunction, findIndex, KeyCodes, getId, warnMutuallyExclusive, warnConditionallyRequiredProps } from '../../Utilities';\nimport { ButtonGrid } from '../../utilities/ButtonGrid/ButtonGrid';\nimport { ColorPickerGridCell } from './ColorPickerGridCell';\nimport { memoizeFunction, warnDeprecations } from '@uifabric/utilities';\nvar getClassNames = classNamesFunction();\nvar COMPONENT_NAME = 'SwatchColorPicker';\n\nvar SwatchColorPickerBase =\n/** @class */\nfunction (_super) {\n  __extends(SwatchColorPickerBase, _super);\n\n  function SwatchColorPickerBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.navigationIdleDelay = 250\n    /* ms */\n    ; // Add an index to each color cells. Memoizes this so that color cells do not re-render on every update.\n\n    _this._getItemsWithIndex = memoizeFunction(function (items) {\n      return items.map(function (item, index) {\n        return __assign(__assign({}, item), {\n          index: index\n        });\n      });\n    });\n\n    _this._onRenderItem = function (item, index) {\n      var _a = _this.props.onRenderColorCell,\n          onRenderColorCell = _a === void 0 ? _this._renderOption : _a;\n      return onRenderColorCell(item, _this._renderOption);\n    };\n    /**\n     * When the whole swatchColorPicker is blurred,\n     * make sure to clear the pending focused stated\n     */\n\n\n    _this._onSwatchColorPickerBlur = function () {\n      if (_this.props.onCellFocused) {\n        _this._cellFocused = false;\n\n        _this.props.onCellFocused();\n      }\n    };\n    /**\n     * Render a color cell\n     * @param item - The item to render\n     * @returns - Element representing the item\n     */\n\n\n    _this._renderOption = function (item) {\n      var props = _this.props;\n      var id = _this._id;\n      return React.createElement(ColorPickerGridCell, {\n        item: item,\n        idPrefix: id,\n        color: item.color,\n        styles: props.getColorGridCellStyles,\n        disabled: props.disabled,\n        onClick: _this._onCellClick,\n        onHover: _this._onGridCellHovered,\n        onFocus: _this._onGridCellFocused,\n        selected: _this.state.selectedIndex !== undefined && _this.state.selectedIndex === item.index,\n        circle: props.cellShape === 'circle',\n        label: item.label,\n        onMouseEnter: _this._onMouseEnter,\n        onMouseMove: _this._onMouseMove,\n        onMouseLeave: _this._onMouseLeave,\n        onWheel: _this._onWheel,\n        onKeyDown: _this._onKeyDown,\n        height: props.cellHeight,\n        width: props.cellWidth,\n        borderWidth: props.cellBorderWidth\n      });\n    };\n    /**\n     * Callback passed to the GridCell that will manage triggering the onCellHovered callback for mouseEnter\n     */\n\n\n    _this._onMouseEnter = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n\n      if (_this.isNavigationIdle && !_this.props.disabled) {\n        ev.currentTarget.focus();\n      }\n\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n\n\n    _this._onMouseMove = function (ev) {\n      if (!_this.props.focusOnHover) {\n        return !_this.isNavigationIdle || !!_this.props.disabled;\n      }\n\n      var targetElement = ev.currentTarget; // If navigation is idle and the targetElement is the focused element bail out\n      // if (!this.isNavigationIdle || (document && targetElement === (document.activeElement as HTMLElement))) {\n\n      if (_this.isNavigationIdle && !(document && targetElement === document.activeElement)) {\n        targetElement.focus();\n      }\n\n      return true;\n    };\n    /**\n     * Callback passed to the GridCell that will manage Hover/Focus updates\n     */\n\n\n    _this._onMouseLeave = function (ev) {\n      var parentSelector = _this.props.mouseLeaveParentSelector;\n\n      if (!_this.props.focusOnHover || !parentSelector || !_this.isNavigationIdle || _this.props.disabled) {\n        return;\n      } // Get the elements that math the given selector\n\n\n      var elements = document.querySelectorAll(parentSelector); // iterate over the elements return to make sure it is a parent of the target and focus it\n\n      for (var index = 0; index < elements.length; index += 1) {\n        if (elements[index].contains(ev.currentTarget)) {\n          /**\n           * IE11 focus() method forces parents to scroll to top of element.\n           * Edge and IE expose a setActive() function for focusable divs that\n           * sets the page focus but does not scroll the parent element.\n           */\n          if (elements[index].setActive) {\n            try {\n              elements[index].setActive();\n            } catch (e) {\n              /* no-op */\n            }\n          } else {\n            elements[index].focus();\n          }\n\n          break;\n        }\n      }\n    };\n    /**\n     * Callback to make sure we don't update the hovered element during mouse wheel\n     */\n\n\n    _this._onWheel = function () {\n      _this._setNavigationTimeout();\n    };\n    /**\n     * Callback that\n     */\n\n\n    _this._onKeyDown = function (ev) {\n      if (ev.which === KeyCodes.up || ev.which === KeyCodes.down || ev.which === KeyCodes.left || ev.which === KeyCodes.right) {\n        _this._setNavigationTimeout();\n      }\n    };\n    /**\n     * Sets a timeout so we won't process any mouse \"hover\" events\n     * while navigating (via mouseWheel or arrowKeys)\n     */\n\n\n    _this._setNavigationTimeout = function () {\n      if (!_this.isNavigationIdle && _this.navigationIdleTimeoutId !== undefined) {\n        _this.async.clearTimeout(_this.navigationIdleTimeoutId);\n\n        _this.navigationIdleTimeoutId = undefined;\n      } else {\n        _this.isNavigationIdle = false;\n      }\n\n      _this.navigationIdleTimeoutId = _this.async.setTimeout(function () {\n        _this.isNavigationIdle = true;\n      }, _this.navigationIdleDelay);\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellHovered callback of the SwatchColorPicker\n     * NOTE: This will not be triggered if shouldFocusOnHover === true\n     */\n\n\n    _this._onGridCellHovered = function (item) {\n      var onCellHovered = _this.props.onCellHovered;\n\n      if (onCellHovered) {\n        return item ? onCellHovered(item.id, item.color) : onCellHovered();\n      }\n    };\n    /**\n     * Callback passed to the GridCell class that will trigger the onCellFocus callback of the SwatchColorPicker\n     */\n\n\n    _this._onGridCellFocused = function (item) {\n      var onCellFocused = _this.props.onCellFocused;\n\n      if (onCellFocused) {\n        if (item) {\n          _this._cellFocused = true;\n          return onCellFocused(item.id, item.color);\n        } else {\n          _this._cellFocused = false;\n          return onCellFocused();\n        }\n      }\n    };\n    /**\n     * Handle the click on a cell\n     * @param item - The cell that the click was fired against\n     */\n\n\n    _this._onCellClick = function (item) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      var index = item.index; // If we have a valid index and it is not already\n      // selected, select it\n\n      if (index >= 0 && index !== _this.state.selectedIndex) {\n        if (_this.props.onCellFocused && _this._cellFocused) {\n          _this._cellFocused = false;\n\n          _this.props.onCellFocused();\n        }\n\n        if (_this.props.onColorChanged) {\n          _this.props.onColorChanged(item.id, item.color);\n        } // Update internal state only if the component is uncontrolled\n\n\n        if (_this.props.isControlled !== true) {\n          _this.setState({\n            selectedIndex: index\n          });\n        }\n      }\n    };\n\n    _this._id = props.id || getId('swatchColorPicker');\n\n    if (process.env.NODE_ENV !== 'production') {\n      warnMutuallyExclusive(COMPONENT_NAME, props, {\n        focusOnHover: 'onHover'\n      });\n      warnConditionallyRequiredProps(COMPONENT_NAME, props, ['focusOnHover'], 'mouseLeaveParentSelector', !!props.mouseLeaveParentSelector);\n      warnDeprecations(COMPONENT_NAME, props, {\n        positionInSet: 'ariaPosInSet',\n        setSize: 'ariaSetSize'\n      });\n    }\n\n    _this.isNavigationIdle = true;\n    _this.async = new Async(_this);\n    var selectedIndex;\n\n    if (props.selectedId) {\n      selectedIndex = _this._getSelectedIndex(props.colorCells, props.selectedId);\n    }\n\n    _this.state = {\n      selectedIndex: selectedIndex\n    };\n    return _this;\n  }\n\n  SwatchColorPickerBase.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.selectedId !== undefined) {\n      this.setState({\n        selectedIndex: this._getSelectedIndex(newProps.colorCells, newProps.selectedId)\n      });\n    }\n  };\n\n  SwatchColorPickerBase.prototype.componentWillUnmount = function () {\n    if (this.props.onCellFocused && this._cellFocused) {\n      this._cellFocused = false;\n      this.props.onCellFocused();\n    }\n\n    this.async.dispose();\n  };\n\n  SwatchColorPickerBase.prototype.render = function () {\n    var _a = this.props,\n        colorCells = _a.colorCells,\n        columnCount = _a.columnCount,\n\n    /* eslint-disable deprecation/deprecation */\n    _b = _a.ariaPosInSet,\n\n    /* eslint-disable deprecation/deprecation */\n    ariaPosInSet = _b === void 0 ? this.props.positionInSet : _b,\n        _c = _a.ariaSetSize,\n        ariaSetSize = _c === void 0 ? this.props.setSize : _c,\n\n    /* eslint-enable deprecation/deprecation */\n    shouldFocusCircularNavigate = _a.shouldFocusCircularNavigate,\n        className = _a.className,\n        doNotContainWithinFocusZone = _a.doNotContainWithinFocusZone,\n        styles = _a.styles,\n        cellMargin = _a.cellMargin;\n    var classNames = getClassNames(styles, {\n      theme: this.props.theme,\n      className: className,\n      cellMargin: cellMargin\n    });\n\n    if (colorCells.length < 1 || columnCount < 1) {\n      return null;\n    }\n\n    return React.createElement(ButtonGrid, __assign({}, this.props, {\n      id: this._id,\n      items: this._getItemsWithIndex(colorCells),\n      columnCount: columnCount,\n      onRenderItem: this._onRenderItem,\n      ariaPosInSet: ariaPosInSet,\n      ariaSetSize: ariaSetSize,\n      shouldFocusCircularNavigate: shouldFocusCircularNavigate,\n      doNotContainWithinFocusZone: doNotContainWithinFocusZone,\n      onBlur: this._onSwatchColorPickerBlur,\n      theme: this.props.theme,\n      styles: {\n        root: classNames.root,\n        tableCell: classNames.tableCell,\n        focusedContainer: classNames.focusedContainer\n      }\n    }));\n  };\n  /**\n   * Get the selected item's index\n   * @param items - The items to search\n   * @param selectedId - The selected item's id to find\n   * @returns - The index of the selected item's id, -1 if there was no match\n   */\n\n\n  SwatchColorPickerBase.prototype._getSelectedIndex = function (items, selectedId) {\n    var selectedIndex = findIndex(items, function (item) {\n      return item.id === selectedId;\n    });\n    return selectedIndex >= 0 ? selectedIndex : undefined;\n  };\n\n  SwatchColorPickerBase.defaultProps = {\n    cellShape: 'circle',\n    disabled: false,\n    shouldFocusCircularNavigate: true,\n    cellMargin: 10\n  };\n  return SwatchColorPickerBase;\n}(React.Component);\n\nexport { SwatchColorPickerBase };","map":null,"metadata":{},"sourceType":"module"}