{"ast":null,"code":"import { __assign, __decorate, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { IconButton } from '../../Button';\nimport { Label } from '../../Label';\nimport { Icon } from '../../Icon';\nimport { initializeComponentRef, warnMutuallyExclusive, Async, getId, KeyCodes, customizable, calculatePrecision, precisionRound, mergeAriaAttributeValues, getNativeProps, divProperties } from '../../Utilities';\nimport { Position } from '../../utilities/positioning';\nimport { getStyles, getArrowButtonStyles } from './SpinButton.styles';\nimport { getClassNames } from './SpinButton.classNames';\nimport { KeytipData } from '../../KeytipData';\nexport var KeyboardSpinDirection;\n\n(function (KeyboardSpinDirection) {\n  KeyboardSpinDirection[KeyboardSpinDirection[\"down\"] = -1] = \"down\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"notSpinning\"] = 0] = \"notSpinning\";\n  KeyboardSpinDirection[KeyboardSpinDirection[\"up\"] = 1] = \"up\";\n})(KeyboardSpinDirection || (KeyboardSpinDirection = {}));\n\nvar SpinButton =\n/** @class */\nfunction (_super) {\n  __extends(SpinButton, _super);\n\n  function SpinButton(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._input = React.createRef();\n    _this._initialStepDelay = 400;\n    _this._stepDelay = 75;\n\n    _this._onFocus = function (ev) {\n      // We can't set focus on a non-existing element\n      if (!_this._input.current) {\n        return;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._stop();\n      }\n\n      _this._input.current.select();\n\n      _this.setState({\n        isFocused: true\n      });\n\n      if (_this.props.onFocus) {\n        _this.props.onFocus(ev);\n      }\n    };\n\n    _this._onBlur = function (ev) {\n      _this._validate(ev);\n\n      _this.setState({\n        isFocused: false\n      });\n\n      if (_this.props.onBlur) {\n        _this.props.onBlur(ev);\n      }\n    };\n\n    _this._onValidate = function (value, event) {\n      if (_this.props.onValidate) {\n        return _this.props.onValidate(value, event);\n      } else {\n        return _this._defaultOnValidate(value);\n      }\n    };\n\n    _this._calculatePrecision = function (props) {\n      var _a = props.precision,\n          precision = _a === void 0 ? Math.max(calculatePrecision(props.step), 0) : _a;\n      return precision;\n    };\n    /**\n     * Validate function to use if one is not passed in\n     */\n\n\n    _this._defaultOnValidate = function (value) {\n      if (value === null || value.trim().length === 0 || isNaN(Number(value))) {\n        return _this._lastValidValue;\n      }\n\n      var newValue = Math.min(_this.props.max, Math.max(_this.props.min, Number(value)));\n      return String(newValue);\n    };\n\n    _this._onIncrement = function (value, event) {\n      if (_this.props.onIncrement) {\n        return _this.props.onIncrement(value, event);\n      } else {\n        return _this._defaultOnIncrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnIncrement = function (value) {\n      var _a = _this.props,\n          max = _a.max,\n          step = _a.step;\n      var newValue = Math.min(Number(value) + Number(step), max);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n\n    _this._onDecrement = function (value, event) {\n      if (_this.props.onDecrement) {\n        return _this.props.onDecrement(value, event);\n      } else {\n        return _this._defaultOnDecrement(value);\n      }\n    };\n    /**\n     * Increment function to use if one is not passed in\n     */\n\n\n    _this._defaultOnDecrement = function (value) {\n      var _a = _this.props,\n          min = _a.min,\n          step = _a.step;\n      var newValue = Math.max(Number(value) - Number(step), min);\n      newValue = precisionRound(newValue, _this._precision);\n      return String(newValue);\n    };\n    /**\n     * This is used when validating text entry in the input on blur or when enter key is pressed\n     * (not when changed via the buttons).\n     * @param event - the event that fired\n     */\n\n\n    _this._validate = function (event) {\n      if (_this.value !== undefined && _this._valueToValidate !== undefined && _this._valueToValidate !== _this._lastValidValue) {\n        var newValue = _this._onValidate(_this._valueToValidate, event); // Done validating this value, so clear it\n\n\n        _this._valueToValidate = undefined;\n\n        if (newValue !== undefined) {\n          _this._lastValidValue = newValue;\n\n          _this.setState({\n            value: newValue\n          });\n        } else {\n          // Value was invalid. Reset state to last valid value.\n          _this.setState({\n            value: _this._lastValidValue\n          });\n        }\n      }\n    };\n    /**\n     * The method is needed to ensure we are updating the actual input value.\n     * without this our value will never change (and validation will not have the correct number)\n     * @param event - the event that was fired\n     */\n\n\n    _this._onInputChange = function (event) {\n      var element = event.target;\n      var value = element.value;\n      _this._valueToValidate = value;\n\n      _this.setState({\n        value: value\n      });\n    };\n    /**\n     * Update the value with the given stepFunction\n     * @param shouldSpin - should we fire off another updateValue when we are done here? This should be true\n     * when spinning in response to a mouseDown\n     * @param stepFunction - function to use to step by\n     * @param event - The event that triggered the updateValue\n     */\n\n\n    _this._updateValue = function (shouldSpin, stepDelay, stepFunction, event) {\n      var newValue = stepFunction(_this.value || '', event);\n\n      if (newValue !== undefined) {\n        _this._lastValidValue = newValue;\n\n        _this.setState({\n          value: newValue\n        });\n      }\n\n      if (_this._spinningByMouse !== shouldSpin) {\n        _this._spinningByMouse = shouldSpin;\n      }\n\n      if (shouldSpin) {\n        _this._currentStepFunctionHandle = _this._async.setTimeout(function () {\n          _this._updateValue(shouldSpin, _this._stepDelay, stepFunction, event);\n        }, stepDelay);\n      }\n    };\n    /**\n     * Stop spinning (clear any currently pending update and set spinning to false)\n     */\n\n\n    _this._stop = function () {\n      if (_this._currentStepFunctionHandle >= 0) {\n        _this._async.clearTimeout(_this._currentStepFunctionHandle);\n\n        _this._currentStepFunctionHandle = -1;\n      }\n\n      if (_this._spinningByMouse || _this.state.keyboardSpinDirection !== KeyboardSpinDirection.notSpinning) {\n        _this._spinningByMouse = false;\n\n        _this.setState({\n          keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n        });\n      }\n    };\n    /**\n     * Handle keydown on the text field. We need to update\n     * the value when up or down arrow are depressed\n     * @param event - the keyboardEvent that was fired\n     */\n\n\n    _this._handleKeyDown = function (event) {\n      // eat the up and down arrow keys to keep focus in the spinButton\n      // (especially when a spinButton is inside of a FocusZone)\n      if (event.which === KeyCodes.up || event.which === KeyCodes.down || event.which === KeyCodes.enter) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n\n      if (_this.props.disabled) {\n        _this._stop();\n\n        return;\n      }\n\n      var spinDirection = KeyboardSpinDirection.notSpinning;\n\n      switch (event.which) {\n        case KeyCodes.up:\n          spinDirection = KeyboardSpinDirection.up;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onIncrement, event);\n\n          break;\n\n        case KeyCodes.down:\n          spinDirection = KeyboardSpinDirection.down;\n\n          _this._updateValue(false\n          /* shouldSpin */\n          , _this._initialStepDelay, _this._onDecrement, event);\n\n          break;\n\n        case KeyCodes.enter:\n          _this._validate(event);\n\n          break;\n\n        case KeyCodes.escape:\n          if (_this.value !== _this._lastValidValue) {\n            _this.setState({\n              value: _this._lastValidValue\n            });\n          }\n\n          break;\n\n        default:\n          break;\n      } // style the increment/decrement button to look active\n      // when the corresponding up/down arrow keys trigger a step\n\n\n      if (_this.state.keyboardSpinDirection !== spinDirection) {\n        _this.setState({\n          keyboardSpinDirection: spinDirection\n        });\n      }\n    };\n    /**\n     * Make sure that we have stopped spinning on keyUp\n     * if the up or down arrow fired this event\n     * @param event - keyboard event\n     */\n\n\n    _this._handleKeyUp = function (event) {\n      if (_this.props.disabled || event.which === KeyCodes.up || event.which === KeyCodes.down) {\n        _this._stop();\n\n        return;\n      }\n    };\n\n    _this._onIncrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onIncrement, event);\n    };\n\n    _this._onDecrementMouseDown = function (event) {\n      _this._updateValue(true\n      /* shouldSpin */\n      , _this._initialStepDelay, _this._onDecrement, event);\n    };\n\n    initializeComponentRef(_this);\n    warnMutuallyExclusive('SpinButton', props, {\n      value: 'defaultValue'\n    }); // Don't use || here because it won't handle empty strings properly\n\n    var _a = props.value,\n        value = _a === void 0 ? props.defaultValue : _a;\n\n    if (value === undefined) {\n      value = typeof props.min === 'number' ? String(props.min) : '0';\n    }\n\n    _this._lastValidValue = value; // Ensure that the autocalculated precision is not negative.\n\n    _this._precision = _this._calculatePrecision(props);\n    _this.state = {\n      isFocused: false,\n      value: value,\n      keyboardSpinDirection: KeyboardSpinDirection.notSpinning\n    };\n    _this._async = new Async(_this);\n    _this._currentStepFunctionHandle = -1;\n    _this._labelId = getId('Label');\n    _this._inputId = getId('input');\n    _this._spinningByMouse = false;\n    _this._valueToValidate = undefined;\n    return _this;\n  }\n\n  SpinButton.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n  };\n  /**\n   * Invoked when a component is receiving new props. This method is not called for the initial render.\n   */\n\n\n  SpinButton.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.value !== undefined) {\n      // Value from props is considered pre-validated\n      this._lastValidValue = newProps.value;\n      this.setState({\n        value: newProps.value\n      });\n    }\n\n    this._precision = this._calculatePrecision(newProps);\n  };\n\n  SpinButton.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        disabled = _a.disabled,\n        label = _a.label,\n        min = _a.min,\n        max = _a.max,\n        labelPosition = _a.labelPosition,\n        iconProps = _a.iconProps,\n        incrementButtonIcon = _a.incrementButtonIcon,\n        incrementButtonAriaLabel = _a.incrementButtonAriaLabel,\n        decrementButtonIcon = _a.decrementButtonIcon,\n        decrementButtonAriaLabel = _a.decrementButtonAriaLabel,\n        ariaLabel = _a.ariaLabel,\n        ariaDescribedBy = _a.ariaDescribedBy,\n        customStyles = _a.styles,\n        customUpArrowButtonStyles = _a.upArrowButtonStyles,\n        customDownArrowButtonStyles = _a.downArrowButtonStyles,\n        theme = _a.theme,\n        ariaPositionInSet = _a.ariaPositionInSet,\n        ariaSetSize = _a.ariaSetSize,\n        ariaValueNow = _a.ariaValueNow,\n        ariaValueText = _a.ariaValueText,\n        keytipProps = _a.keytipProps,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        iconButtonProps = _a.iconButtonProps;\n    var _b = this.state,\n        isFocused = _b.isFocused,\n        keyboardSpinDirection = _b.keyboardSpinDirection;\n    var value = this.value;\n    var classNames = this.props.getClassNames ? this.props.getClassNames(theme, disabled, isFocused, keyboardSpinDirection, labelPosition, className) : getClassNames(getStyles(theme, customStyles), disabled, isFocused, keyboardSpinDirection, labelPosition, className);\n    var nativeProps = getNativeProps(this.props, divProperties, ['onBlur', 'onFocus', 'className']);\n    return React.createElement(\"div\", {\n      className: classNames.root\n    }, labelPosition !== Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, __assign({}, iconProps, {\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    })), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)), React.createElement(KeytipData, {\n      keytipProps: keytipProps,\n      disabled: disabled\n    }, function (keytipAttributes) {\n      return React.createElement(\"div\", __assign({}, nativeProps, {\n        className: classNames.spinButtonWrapper,\n        \"aria-label\": ariaLabel && ariaLabel,\n        \"aria-posinset\": ariaPositionInSet,\n        \"aria-setsize\": ariaSetSize,\n        \"data-ktp-target\": keytipAttributes['data-ktp-target']\n      }), React.createElement(\"input\", __assign({\n        value: value,\n        id: _this._inputId,\n        onChange: _this._onChange,\n        onInput: _this._onInputChange,\n        className: classNames.input,\n        type: \"text\",\n        autoComplete: \"off\",\n        role: \"spinbutton\",\n        \"aria-labelledby\": label && _this._labelId,\n        \"aria-valuenow\": typeof ariaValueNow === 'number' ? ariaValueNow : value && !isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? Number(value) : undefined,\n        \"aria-valuetext\": typeof ariaValueText === 'string' ? ariaValueText : !value || isNaN(Number(value)) // Number('') is 0 which may not be desirable\n        ? value : undefined,\n        \"aria-valuemin\": min,\n        \"aria-valuemax\": max,\n        \"aria-describedby\": mergeAriaAttributeValues(ariaDescribedBy, keytipAttributes['aria-describedby']),\n        onBlur: _this._onBlur,\n        ref: _this._input,\n        onFocus: _this._onFocus,\n        onKeyDown: _this._handleKeyDown,\n        onKeyUp: _this._handleKeyUp,\n        disabled: disabled,\n        \"aria-disabled\": disabled,\n        \"data-lpignore\": true,\n        \"data-ktp-execute-target\": keytipAttributes['data-ktp-execute-target']\n      }, inputProps)), React.createElement(\"span\", {\n        className: classNames.arrowBox\n      }, React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, true, customUpArrowButtonStyles),\n        className: 'ms-UpButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.up,\n        disabled: disabled,\n        iconProps: incrementButtonIcon,\n        onMouseDown: _this._onIncrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: incrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps)), React.createElement(IconButton, __assign({\n        styles: getArrowButtonStyles(theme, false, customDownArrowButtonStyles),\n        className: 'ms-DownButton',\n        checked: keyboardSpinDirection === KeyboardSpinDirection.down,\n        disabled: disabled,\n        iconProps: decrementButtonIcon,\n        onMouseDown: _this._onDecrementMouseDown,\n        onMouseLeave: _this._stop,\n        onMouseUp: _this._stop,\n        tabIndex: -1,\n        ariaLabel: decrementButtonAriaLabel,\n        \"data-is-focusable\": false\n      }, iconButtonProps))));\n    }), labelPosition === Position.bottom && (iconProps || label) && React.createElement(\"div\", {\n      className: classNames.labelWrapper\n    }, iconProps && React.createElement(Icon, {\n      iconName: iconProps.iconName,\n      className: classNames.icon,\n      \"aria-hidden\": \"true\"\n    }), label && React.createElement(Label, {\n      id: this._labelId,\n      htmlFor: this._inputId,\n      className: classNames.label,\n      disabled: disabled\n    }, label)));\n  };\n\n  SpinButton.prototype.focus = function () {\n    if (this._input.current) {\n      this._input.current.focus();\n    }\n  };\n\n  Object.defineProperty(SpinButton.prototype, \"value\", {\n    /**\n     * Gets the value of the spin button.\n     */\n    get: function get() {\n      // TODO (version 8): value from props should ALWAYS override value from state.\n      // In a class component the code should be:\n      // const { value = this.state.value } = this.props;\n      // return value;\n      return this.state.value;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SpinButton.prototype._onChange = function () {\n    /**\n     * A noop input change handler. Using onInput instead of onChange was meant to address an issue\n     * which apparently has been resolved in React 16 (https://github.com/facebook/react/issues/7027).\n     * The no-op onChange handler was still needed because React gives console errors if an input\n     * doesn't have onChange.\n     *\n     * TODO (Fabric 8?) - switch to just calling onChange (this is a breaking change for any tests,\n     * ours or 3rd-party, which simulate entering text in a SpinButton)\n     */\n  };\n\n  SpinButton.defaultProps = {\n    step: 1,\n    min: 0,\n    max: 100,\n    disabled: false,\n    labelPosition: Position.start,\n    label: '',\n    incrementButtonIcon: {\n      iconName: 'ChevronUpSmall'\n    },\n    decrementButtonIcon: {\n      iconName: 'ChevronDownSmall'\n    }\n  };\n  SpinButton = __decorate([customizable('SpinButton', ['theme', 'styles'], true)], SpinButton);\n  return SpinButton;\n}(React.Component);\n\nexport { SpinButton };","map":null,"metadata":{},"sourceType":"module"}