{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { initializeComponentRef, KeyCodes, classNamesFunction, css, styled } from '../../../Utilities';\nimport { CommandButton } from '../../../Button';\nimport { Spinner } from '../../../Spinner';\nimport { Announced } from '../../../Announced';\nimport { SuggestionActionType } from './Suggestions.types';\nimport { SuggestionsItem } from './SuggestionsItem';\nimport { getStyles as suggestionsItemStyles } from './SuggestionsItem.styles';\nimport * as stylesImport from './Suggestions.scss';\nvar legacyStyles = stylesImport;\nvar getClassNames = classNamesFunction();\nvar StyledSuggestionsItem = styled(SuggestionsItem, suggestionsItemStyles, undefined, {\n  scope: 'SuggestionItem'\n});\n/**\n * {@docCategory Pickers}\n */\n\nvar Suggestions =\n/** @class */\nfunction (_super) {\n  __extends(Suggestions, _super);\n\n  function Suggestions(suggestionsProps) {\n    var _this = _super.call(this, suggestionsProps) || this;\n\n    _this._forceResolveButton = React.createRef();\n    _this._searchForMoreButton = React.createRef();\n    _this._selectedElement = React.createRef();\n    /**\n     * Returns true if the event was handled, false otherwise\n     */\n\n    _this.tryHandleKeyDown = function (keyCode, currentSuggestionIndex) {\n      var isEventHandled = false;\n      var newSelectedActionType = null;\n      var currentSelectedAction = _this.state.selectedActionType;\n      var suggestionLength = _this.props.suggestions.length;\n\n      if (keyCode === KeyCodes.down) {\n        switch (currentSelectedAction) {\n          case SuggestionActionType.forceResolve:\n            if (suggestionLength > 0) {\n              _this._refocusOnSuggestions(keyCode);\n\n              newSelectedActionType = SuggestionActionType.none;\n            } else if (_this._searchForMoreButton.current) {\n              newSelectedActionType = SuggestionActionType.searchMore;\n            } else {\n              newSelectedActionType = SuggestionActionType.forceResolve;\n            }\n\n            break;\n\n          case SuggestionActionType.searchMore:\n            if (_this._forceResolveButton.current) {\n              newSelectedActionType = SuggestionActionType.forceResolve;\n            } else if (suggestionLength > 0) {\n              _this._refocusOnSuggestions(keyCode);\n\n              newSelectedActionType = SuggestionActionType.none;\n            } else {\n              newSelectedActionType = SuggestionActionType.searchMore;\n            }\n\n            break;\n\n          case SuggestionActionType.none:\n            if (currentSuggestionIndex === -1 && _this._forceResolveButton.current) {\n              newSelectedActionType = SuggestionActionType.forceResolve;\n            }\n\n            break;\n        }\n      } else if (keyCode === KeyCodes.up) {\n        switch (currentSelectedAction) {\n          case SuggestionActionType.forceResolve:\n            if (_this._searchForMoreButton.current) {\n              newSelectedActionType = SuggestionActionType.searchMore;\n            } else if (suggestionLength > 0) {\n              _this._refocusOnSuggestions(keyCode);\n\n              newSelectedActionType = SuggestionActionType.none;\n            }\n\n            break;\n\n          case SuggestionActionType.searchMore:\n            if (suggestionLength > 0) {\n              _this._refocusOnSuggestions(keyCode);\n\n              newSelectedActionType = SuggestionActionType.none;\n            } else if (_this._forceResolveButton.current) {\n              newSelectedActionType = SuggestionActionType.forceResolve;\n            }\n\n            break;\n\n          case SuggestionActionType.none:\n            if (currentSuggestionIndex === -1 && _this._searchForMoreButton.current) {\n              newSelectedActionType = SuggestionActionType.searchMore;\n            }\n\n            break;\n        }\n      }\n\n      if (newSelectedActionType !== null) {\n        _this.setState({\n          selectedActionType: newSelectedActionType\n        });\n\n        isEventHandled = true;\n      }\n\n      return isEventHandled;\n    };\n\n    _this._getAlertText = function () {\n      var _a = _this.props,\n          isLoading = _a.isLoading,\n          isSearching = _a.isSearching,\n          suggestions = _a.suggestions,\n          suggestionsAvailableAlertText = _a.suggestionsAvailableAlertText,\n          noResultsFoundText = _a.noResultsFoundText;\n\n      if (!isLoading && !isSearching) {\n        if (suggestions.length > 0) {\n          return suggestionsAvailableAlertText || '';\n        }\n\n        if (noResultsFoundText) {\n          return noResultsFoundText;\n        }\n      }\n\n      return '';\n    };\n\n    _this._getMoreResults = function () {\n      if (_this.props.onGetMoreResults) {\n        _this.props.onGetMoreResults();\n      }\n    };\n\n    _this._forceResolve = function () {\n      if (_this.props.createGenericItem) {\n        _this.props.createGenericItem();\n      }\n    };\n\n    _this._shouldShowForceResolve = function () {\n      return _this.props.showForceResolve ? _this.props.showForceResolve() : false;\n    };\n\n    _this._onClickTypedSuggestionsItem = function (item, index) {\n      return function (ev) {\n        _this.props.onSuggestionClick(ev, item, index);\n      };\n    };\n\n    _this._refocusOnSuggestions = function (keyCode) {\n      if (typeof _this.props.refocusSuggestions === 'function') {\n        _this.props.refocusSuggestions(keyCode);\n      }\n    };\n\n    _this._onRemoveTypedSuggestionsItem = function (item, index) {\n      return function (ev) {\n        var onSuggestionRemove = _this.props.onSuggestionRemove;\n        onSuggestionRemove(ev, item, index);\n        ev.stopPropagation();\n      };\n    };\n\n    initializeComponentRef(_this);\n    _this.state = {\n      selectedActionType: SuggestionActionType.none\n    };\n    return _this;\n  }\n\n  Suggestions.prototype.componentDidMount = function () {\n    this.scrollSelected();\n    this.activeSelectedElement = this._selectedElement ? this._selectedElement.current : null;\n  };\n\n  Suggestions.prototype.componentDidUpdate = function () {\n    // Only scroll to selected element if the selected element has changed. Otherwise do nothing.\n    // This prevents some odd behavior where scrolling the active element out of view and clicking on a selected element\n    // will trigger a focus event and not give the clicked element the click.\n    if (this._selectedElement.current && this.activeSelectedElement !== this._selectedElement.current) {\n      this.scrollSelected();\n      this.activeSelectedElement = this._selectedElement.current;\n    }\n  };\n\n  Suggestions.prototype.render = function () {\n    var _a, _b;\n\n    var _this = this;\n\n    var _c = this.props,\n        forceResolveText = _c.forceResolveText,\n        mostRecentlyUsedHeaderText = _c.mostRecentlyUsedHeaderText,\n        searchForMoreText = _c.searchForMoreText,\n        className = _c.className,\n        moreSuggestionsAvailable = _c.moreSuggestionsAvailable,\n        noResultsFoundText = _c.noResultsFoundText,\n        suggestions = _c.suggestions,\n        isLoading = _c.isLoading,\n        isSearching = _c.isSearching,\n        loadingText = _c.loadingText,\n        onRenderNoResultFound = _c.onRenderNoResultFound,\n        searchingText = _c.searchingText,\n        isMostRecentlyUsedVisible = _c.isMostRecentlyUsedVisible,\n        resultsMaximumNumber = _c.resultsMaximumNumber,\n        resultsFooterFull = _c.resultsFooterFull,\n        resultsFooter = _c.resultsFooter,\n        _d = _c.isResultsFooterVisible,\n        isResultsFooterVisible = _d === void 0 ? true : _d,\n        suggestionsHeaderText = _c.suggestionsHeaderText,\n        suggestionsClassName = _c.suggestionsClassName,\n        theme = _c.theme,\n        styles = _c.styles,\n        suggestionsListId = _c.suggestionsListId; // TODO\n    // Clean this up by leaving only the first part after removing support for SASS.\n    // Currently we can not remove the SASS styles from Suggestions class because it\n    // might be used by consumers separately from pickers extending from BasePicker\n    // and have not used the new 'styles' prop. Because it's expecting a type parameter,\n    // we can not use the 'styled' function without adding some helpers which can break\n    // downstream consumers who did not use the new helpers.\n    // We check for 'styles' prop which is going to be injected by the 'styled' HOC\n    // in BasePicker when the typed Suggestions class is ready to be rendered. If the check\n    // passes we can use the CSS-in-JS styles. If the check fails (ex: custom picker),\n    // then we just use the old SASS styles instead.\n\n    this._classNames = styles ? getClassNames(styles, {\n      theme: theme,\n      className: className,\n      suggestionsClassName: suggestionsClassName,\n      forceResolveButtonSelected: this.state.selectedActionType === SuggestionActionType.forceResolve,\n      searchForMoreButtonSelected: this.state.selectedActionType === SuggestionActionType.searchMore\n    }) : {\n      root: css('ms-Suggestions', className, legacyStyles.root),\n      title: css('ms-Suggestions-title', legacyStyles.suggestionsTitle),\n      searchForMoreButton: css('ms-SearchMore-button', legacyStyles.actionButton, (_a = {}, _a['is-selected ' + legacyStyles.buttonSelected] = this.state.selectedActionType === SuggestionActionType.searchMore, _a)),\n      forceResolveButton: css('ms-forceResolve-button', legacyStyles.actionButton, (_b = {}, _b['is-selected ' + legacyStyles.buttonSelected] = this.state.selectedActionType === SuggestionActionType.forceResolve, _b)),\n      suggestionsAvailable: css('ms-Suggestions-suggestionsAvailable', legacyStyles.suggestionsAvailable),\n      suggestionsContainer: css('ms-Suggestions-container', legacyStyles.suggestionsContainer, suggestionsClassName),\n      noSuggestions: css('ms-Suggestions-none', legacyStyles.suggestionsNone)\n    };\n    var spinnerStyles = this._classNames.subComponentStyles ? this._classNames.subComponentStyles.spinner : undefined; // TODO: cleanup after refactor of pickers to composition pattern and remove SASS support.\n\n    var spinnerClassNameOrStyles = styles ? {\n      styles: spinnerStyles\n    } : {\n      className: css('ms-Suggestions-spinner', legacyStyles.suggestionsSpinner)\n    };\n\n    var noResults = function noResults() {\n      return noResultsFoundText ? React.createElement(\"div\", {\n        className: _this._classNames.noSuggestions\n      }, noResultsFoundText) : null;\n    }; // MostRecently Used text should supercede the header text if it's there and available.\n\n\n    var headerText = suggestionsHeaderText;\n\n    if (isMostRecentlyUsedVisible && mostRecentlyUsedHeaderText) {\n      headerText = mostRecentlyUsedHeaderText;\n    }\n\n    var footerTitle = undefined;\n\n    if (isResultsFooterVisible) {\n      footerTitle = suggestions.length >= resultsMaximumNumber ? resultsFooterFull : resultsFooter;\n    }\n\n    var hasNoSuggestions = (!suggestions || !suggestions.length) && !isLoading;\n    var divProps = hasNoSuggestions || isLoading ? {\n      role: 'dialog',\n      id: suggestionsListId\n    } : {};\n    var forceResolveId = this.state.selectedActionType === SuggestionActionType.forceResolve ? 'sug-selectedAction' : undefined;\n    var searchForMoreId = this.state.selectedActionType === SuggestionActionType.searchMore ? 'sug-selectedAction' : undefined;\n    return React.createElement(\"div\", __assign({\n      className: this._classNames.root\n    }, divProps), React.createElement(Announced, {\n      message: this._getAlertText(),\n      \"aria-live\": \"polite\"\n    }), headerText ? React.createElement(\"div\", {\n      className: this._classNames.title\n    }, headerText) : null, forceResolveText && this._shouldShowForceResolve() && React.createElement(CommandButton, {\n      componentRef: this._forceResolveButton,\n      className: this._classNames.forceResolveButton,\n      id: forceResolveId,\n      onClick: this._forceResolve,\n      \"data-automationid\": 'sug-forceResolve'\n    }, forceResolveText), isLoading && React.createElement(Spinner, __assign({}, spinnerClassNameOrStyles, {\n      label: loadingText\n    })), hasNoSuggestions ? onRenderNoResultFound ? onRenderNoResultFound(undefined, noResults) : noResults() : this._renderSuggestions(), searchForMoreText && moreSuggestionsAvailable && React.createElement(CommandButton, {\n      componentRef: this._searchForMoreButton,\n      className: this._classNames.searchForMoreButton,\n      iconProps: {\n        iconName: 'Search'\n      },\n      id: searchForMoreId,\n      onClick: this._getMoreResults,\n      \"data-automationid\": 'sug-searchForMore'\n    }, searchForMoreText), isSearching ? React.createElement(Spinner, __assign({}, spinnerClassNameOrStyles, {\n      label: searchingText\n    })) : null, footerTitle && !moreSuggestionsAvailable && !isMostRecentlyUsedVisible && !isSearching ? React.createElement(\"div\", {\n      className: this._classNames.title\n    }, footerTitle(this.props)) : null);\n  };\n\n  Suggestions.prototype.hasSuggestedAction = function () {\n    return !!this._searchForMoreButton.current || !!this._forceResolveButton.current;\n  };\n\n  Suggestions.prototype.hasSuggestedActionSelected = function () {\n    return this.state.selectedActionType !== SuggestionActionType.none;\n  };\n\n  Suggestions.prototype.executeSelectedAction = function () {\n    switch (this.state.selectedActionType) {\n      case SuggestionActionType.forceResolve:\n        this._forceResolve();\n\n        break;\n\n      case SuggestionActionType.searchMore:\n        this._getMoreResults();\n\n        break;\n    }\n  };\n\n  Suggestions.prototype.focusAboveSuggestions = function () {\n    if (this._forceResolveButton.current) {\n      this.setState({\n        selectedActionType: SuggestionActionType.forceResolve\n      });\n    } else if (this._searchForMoreButton.current) {\n      this.setState({\n        selectedActionType: SuggestionActionType.searchMore\n      });\n    }\n  };\n\n  Suggestions.prototype.focusBelowSuggestions = function () {\n    if (this._searchForMoreButton.current) {\n      this.setState({\n        selectedActionType: SuggestionActionType.searchMore\n      });\n    } else if (this._forceResolveButton.current) {\n      this.setState({\n        selectedActionType: SuggestionActionType.forceResolve\n      });\n    }\n  };\n\n  Suggestions.prototype.focusSearchForMoreButton = function () {\n    if (this._searchForMoreButton.current) {\n      this._searchForMoreButton.current.focus();\n    }\n  }; // TODO get the element to scroll into view properly regardless of direction.\n\n\n  Suggestions.prototype.scrollSelected = function () {\n    if (this._selectedElement.current && this._selectedElement.current.scrollIntoView !== undefined) {\n      this._selectedElement.current.scrollIntoView(false);\n    }\n  };\n\n  Suggestions.prototype._renderSuggestions = function () {\n    var _this = this;\n\n    var _a = this.props,\n        onRenderSuggestion = _a.onRenderSuggestion,\n        removeSuggestionAriaLabel = _a.removeSuggestionAriaLabel,\n        suggestionsItemClassName = _a.suggestionsItemClassName,\n        resultsMaximumNumber = _a.resultsMaximumNumber,\n        showRemoveButtons = _a.showRemoveButtons,\n        suggestionsContainerAriaLabel = _a.suggestionsContainerAriaLabel,\n        suggestionsListId = _a.suggestionsListId;\n    var suggestions = this.props.suggestions;\n    var StyledTypedSuggestionsItem = StyledSuggestionsItem;\n    var selectedIndex = -1;\n    suggestions.some(function (element, index) {\n      if (element.selected) {\n        selectedIndex = index;\n        return true;\n      }\n\n      return false;\n    });\n\n    if (resultsMaximumNumber) {\n      suggestions = selectedIndex >= resultsMaximumNumber ? suggestions.slice(selectedIndex - resultsMaximumNumber + 1, selectedIndex + 1) : suggestions.slice(0, resultsMaximumNumber);\n    }\n\n    if (suggestions.length === 0) {\n      return null;\n    }\n\n    return React.createElement(\"div\", {\n      className: this._classNames.suggestionsContainer,\n      id: suggestionsListId,\n      role: \"listbox\",\n      \"aria-label\": suggestionsContainerAriaLabel\n    }, suggestions.map(function (suggestion, index) {\n      return React.createElement(\"div\", {\n        ref: suggestion.selected ? _this._selectedElement : undefined,\n        key: suggestion.item.key ? suggestion.item.key : index\n      }, React.createElement(StyledTypedSuggestionsItem, {\n        suggestionModel: suggestion,\n        RenderSuggestion: onRenderSuggestion,\n        onClick: _this._onClickTypedSuggestionsItem(suggestion.item, index),\n        className: suggestionsItemClassName,\n        showRemoveButton: showRemoveButtons,\n        removeButtonAriaLabel: removeSuggestionAriaLabel,\n        onRemoveItem: _this._onRemoveTypedSuggestionsItem(suggestion.item, index),\n        id: 'sug-' + index\n      }));\n    }));\n  };\n\n  return Suggestions;\n}(React.Component);\n\nexport { Suggestions };","map":null,"metadata":{},"sourceType":"module"}