{"ast":null,"code":"import * as React from 'react';\nimport { useConst } from './useConst';\nexport function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {\n  var _a = React.useState(defaultUncontrolledValue),\n      value = _a[0],\n      setValue = _a[1];\n\n  var isControlled = useConst(controlledValue !== undefined);\n  var currentValue = isControlled ? controlledValue : value; // Duplicate the current value and onChange in refs so they're accessible from\n  // setValueOrCallOnChange without creating a new callback every time\n\n  var valueRef = React.useRef(currentValue);\n  var onChangeRef = React.useRef(onChange);\n  React.useEffect(function () {\n    valueRef.current = currentValue;\n    onChangeRef.current = onChange;\n  }); // To match the behavior of the setter returned by React.useState, this callback's identity\n  // should never change. This means it MUST NOT directly reference variables that can change.\n\n  var setValueOrCallOnChange = useConst(function () {\n    return function (update, ev) {\n      // Assuming here that TValue is not a function, because a controllable value will typically\n      // be something a user can enter as input\n      var newValue = typeof update === 'function' ? update(valueRef.current) : update;\n\n      if (onChangeRef.current) {\n        onChangeRef.current(ev, newValue);\n      }\n\n      if (!isControlled) {\n        setValue(newValue);\n      }\n    };\n  });\n  return [currentValue, setValueOrCallOnChange];\n}","map":null,"metadata":{},"sourceType":"module"}