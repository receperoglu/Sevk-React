{"ast":null,"code":"import { __assign, __extends, __spreadArrays } from \"tslib\";\nimport * as React from 'react';\nimport { initializeComponentRef, getRTL, classNamesFunction, getNativeProps, htmlElementProperties } from '../../Utilities';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Link } from '../../Link';\nimport { Icon } from '../../Icon';\nimport { IconButton } from '../../Button';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport { ResizeGroup } from '../../ResizeGroup';\nimport { TooltipHost, TooltipOverflowMode } from '../../Tooltip';\nvar getClassNames = classNamesFunction();\nvar OVERFLOW_KEY = 'overflow';\n\nvar nullFunction = function nullFunction() {\n  return null;\n};\n\nvar nonActionableItemProps = {\n  styles: function styles(props) {\n    var theme = props.theme;\n    return {\n      root: {\n        selectors: {\n          '&.is-disabled': {\n            color: theme.semanticColors.bodyText\n          }\n        }\n      }\n    };\n  }\n};\n/**\n * {@docCategory Breadcrumb}\n */\n\nvar BreadcrumbBase =\n/** @class */\nfunction (_super) {\n  __extends(BreadcrumbBase, _super);\n\n  function BreadcrumbBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._focusZone = React.createRef();\n    /**\n     * Remove the first rendered item past the overlow point and put it and the end the overflow set.\n     */\n\n    _this._onReduceData = function (data) {\n      var renderedItems = data.renderedItems,\n          renderedOverflowItems = data.renderedOverflowItems;\n      var overflowIndex = data.props.overflowIndex;\n      var movedItem = renderedItems[overflowIndex];\n\n      if (!movedItem) {\n        return undefined;\n      }\n\n      renderedItems = __spreadArrays(renderedItems);\n      renderedItems.splice(overflowIndex, 1);\n      renderedOverflowItems = __spreadArrays(renderedOverflowItems, [movedItem]);\n      return __assign(__assign({}, data), {\n        renderedItems: renderedItems,\n        renderedOverflowItems: renderedOverflowItems\n      });\n    };\n    /**\n     * Remove the last item of the overflow set and insert the item as the start of the rendered set past the overflow\n     * point.\n     */\n\n\n    _this._onGrowData = function (data) {\n      var renderedItems = data.renderedItems,\n          renderedOverflowItems = data.renderedOverflowItems;\n      var _a = data.props,\n          overflowIndex = _a.overflowIndex,\n          maxDisplayedItems = _a.maxDisplayedItems;\n      renderedOverflowItems = __spreadArrays(renderedOverflowItems);\n      var movedItem = renderedOverflowItems.pop();\n\n      if (!movedItem || renderedItems.length >= maxDisplayedItems) {\n        return undefined;\n      }\n\n      renderedItems = __spreadArrays(renderedItems);\n      renderedItems.splice(overflowIndex, 0, movedItem);\n      return __assign(__assign({}, data), {\n        renderedItems: renderedItems,\n        renderedOverflowItems: renderedOverflowItems\n      });\n    };\n\n    _this._onRenderBreadcrumb = function (data) {\n      var _a = data.props,\n          ariaLabel = _a.ariaLabel,\n          _b = _a.dividerAs,\n          DividerType = _b === void 0 ? Icon : _b,\n          _c = _a.onRenderItem,\n          onRenderItem = _c === void 0 ? _this._onRenderItem : _c,\n          overflowAriaLabel = _a.overflowAriaLabel,\n          overflowIndex = _a.overflowIndex,\n          onRenderOverflowIcon = _a.onRenderOverflowIcon,\n          overflowButtonAs = _a.overflowButtonAs;\n      var renderedOverflowItems = data.renderedOverflowItems,\n          renderedItems = data.renderedItems;\n      var contextualItems = renderedOverflowItems.map(function (item) {\n        var isActionable = !!(item.onClick || item.href);\n        return {\n          text: item.text,\n          name: item.text,\n          key: item.key,\n          onClick: item.onClick ? _this._onBreadcrumbClicked.bind(_this, item) : null,\n          href: item.href,\n          disabled: !isActionable,\n          itemProps: isActionable ? undefined : nonActionableItemProps\n        };\n      }); // Find index of last rendered item so the divider icon\n      // knows not to render on that item\n\n      var lastItemIndex = renderedItems.length - 1;\n      var hasOverflowItems = renderedOverflowItems && renderedOverflowItems.length !== 0;\n      var itemElements = renderedItems.map(function (item, index) {\n        return React.createElement(\"li\", {\n          className: _this._classNames.listItem,\n          key: item.key || String(index)\n        }, onRenderItem(item, _this._onRenderItem), (index !== lastItemIndex || hasOverflowItems && index === overflowIndex - 1) && React.createElement(DividerType, {\n          className: _this._classNames.chevron,\n          iconName: getRTL(_this.props.theme) ? 'ChevronLeft' : 'ChevronRight',\n          item: item\n        }));\n      });\n\n      if (hasOverflowItems) {\n        var iconProps = !onRenderOverflowIcon ? {\n          iconName: 'More'\n        } : {};\n        var onRenderMenuIcon = onRenderOverflowIcon ? onRenderOverflowIcon : nullFunction;\n        var OverflowButton = overflowButtonAs ? overflowButtonAs : IconButton;\n        itemElements.splice(overflowIndex, 0, React.createElement(\"li\", {\n          className: _this._classNames.overflow,\n          key: OVERFLOW_KEY\n        }, React.createElement(OverflowButton, {\n          className: _this._classNames.overflowButton,\n          iconProps: iconProps,\n          role: \"button\",\n          \"aria-haspopup\": \"true\",\n          ariaLabel: overflowAriaLabel,\n          onRenderMenuIcon: onRenderMenuIcon,\n          menuProps: {\n            items: contextualItems,\n            directionalHint: DirectionalHint.bottomLeftEdge\n          }\n        }), overflowIndex !== lastItemIndex + 1 && React.createElement(DividerType, {\n          className: _this._classNames.chevron,\n          iconName: getRTL(_this.props.theme) ? 'ChevronLeft' : 'ChevronRight',\n          item: renderedOverflowItems[renderedOverflowItems.length - 1]\n        })));\n      }\n\n      var nativeProps = getNativeProps(_this.props, htmlElementProperties, ['className']);\n      return React.createElement(\"div\", __assign({\n        className: _this._classNames.root,\n        role: \"navigation\",\n        \"aria-label\": ariaLabel\n      }, nativeProps), React.createElement(FocusZone, __assign({\n        componentRef: _this._focusZone,\n        direction: FocusZoneDirection.horizontal\n      }, _this.props.focusZoneProps), React.createElement(\"ol\", {\n        className: _this._classNames.list\n      }, itemElements)));\n    };\n\n    _this._onRenderItem = function (item) {\n      if (item.onClick || item.href) {\n        return React.createElement(Link, {\n          as: item.as,\n          className: _this._classNames.itemLink,\n          href: item.href,\n          \"aria-current\": item.isCurrentItem ? 'page' : undefined,\n          // eslint-disable-next-line react/jsx-no-bind\n          onClick: _this._onBreadcrumbClicked.bind(_this, item),\n          role: item.role\n        }, React.createElement(TooltipHost, __assign({\n          content: item.text,\n          overflowMode: TooltipOverflowMode.Parent\n        }, _this.props.tooltipHostProps), item.text));\n      } else {\n        var Tag = item.as || 'span';\n        return React.createElement(Tag, {\n          className: _this._classNames.item\n        }, React.createElement(TooltipHost, __assign({\n          content: item.text,\n          overflowMode: TooltipOverflowMode.Parent\n        }, _this.props.tooltipHostProps), item.text));\n      }\n    };\n\n    _this._onBreadcrumbClicked = function (item, ev) {\n      if (item.onClick) {\n        item.onClick(ev, item);\n      }\n    };\n\n    initializeComponentRef(_this);\n\n    _this._validateProps(props);\n\n    return _this;\n  }\n  /**\n   * Sets focus to the first breadcrumb link.\n   */\n\n\n  BreadcrumbBase.prototype.focus = function () {\n    if (this._focusZone.current) {\n      this._focusZone.current.focus();\n    }\n  };\n\n  BreadcrumbBase.prototype.render = function () {\n    this._validateProps(this.props);\n\n    var _a = this.props,\n        _b = _a.onReduceData,\n        onReduceData = _b === void 0 ? this._onReduceData : _b,\n        _c = _a.onGrowData,\n        onGrowData = _c === void 0 ? this._onGrowData : _c,\n        overflowIndex = _a.overflowIndex,\n        maxDisplayedItems = _a.maxDisplayedItems,\n        items = _a.items,\n        className = _a.className,\n        theme = _a.theme,\n        styles = _a.styles;\n\n    var renderedItems = __spreadArrays(items);\n\n    var renderedOverflowItems = renderedItems.splice(overflowIndex, renderedItems.length - maxDisplayedItems);\n    var breadcrumbData = {\n      props: this.props,\n      renderedItems: renderedItems,\n      renderedOverflowItems: renderedOverflowItems\n    };\n    this._classNames = getClassNames(styles, {\n      className: className,\n      theme: theme\n    });\n    return React.createElement(ResizeGroup, {\n      onRenderData: this._onRenderBreadcrumb,\n      onReduceData: onReduceData,\n      onGrowData: onGrowData,\n      data: breadcrumbData\n    });\n  };\n  /**\n   * Validate incoming props\n   * @param props - Props to validate\n   */\n\n\n  BreadcrumbBase.prototype._validateProps = function (props) {\n    var maxDisplayedItems = props.maxDisplayedItems,\n        overflowIndex = props.overflowIndex,\n        items = props.items;\n\n    if (overflowIndex < 0 || maxDisplayedItems > 1 && overflowIndex > maxDisplayedItems - 1 || items.length > 0 && overflowIndex > items.length - 1) {\n      throw new Error('Breadcrumb: overflowIndex out of range');\n    }\n  };\n\n  BreadcrumbBase.defaultProps = {\n    items: [],\n    maxDisplayedItems: 999,\n    overflowIndex: 0\n  };\n  return BreadcrumbBase;\n}(React.Component);\n\nexport { BreadcrumbBase };","map":null,"metadata":{},"sourceType":"module"}