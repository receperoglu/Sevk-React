{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { Async, EventGroup, divProperties, getNativeProps, warnDeprecations } from '../../Utilities';\nimport { ResizeGroupDirection } from './ResizeGroup.types';\nimport { initializeComponentRef } from '@uifabric/utilities';\nvar RESIZE_DELAY = 16;\n/**\n * Returns a simple object is able to store measurements with a given key.\n */\n\nexport var getMeasurementCache = function getMeasurementCache() {\n  var measurementsCache = {};\n  return {\n    /**\n     * Checks if the provided data has a cacheKey. If it has a cacheKey and there is a\n     * corresponding entry in the measurementsCache, then it will return that value.\n     * Returns undefined otherwise.\n     */\n    getCachedMeasurement: function getCachedMeasurement(data) {\n      if (data && data.cacheKey && measurementsCache.hasOwnProperty(data.cacheKey)) {\n        return measurementsCache[data.cacheKey];\n      }\n\n      return undefined;\n    },\n\n    /**\n     * Should be called whenever there is a new measurement associated with a given data object.\n     * If the data has a cacheKey, store that measurement in the measurementsCache.\n     */\n    addMeasurementToCache: function addMeasurementToCache(data, measurement) {\n      if (data.cacheKey) {\n        measurementsCache[data.cacheKey] = measurement;\n      }\n    }\n  };\n};\n/**\n * Returns a function that is able to compute the next state for the ResizeGroup given the current\n * state and any measurement updates.\n */\n\nexport var getNextResizeGroupStateProvider = function getNextResizeGroupStateProvider(measurementCache) {\n  if (measurementCache === void 0) {\n    measurementCache = getMeasurementCache();\n  }\n\n  var _measurementCache = measurementCache;\n\n  var _containerDimension;\n  /**\n   * Gets the width/height of the data rendered in a hidden div.\n   * @param measuredData - The data corresponding to the measurement we wish to take.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _getMeasuredDimension(measuredData, getElementToMeasureDimension) {\n    var cachedDimension = _measurementCache.getCachedMeasurement(measuredData);\n\n    if (cachedDimension !== undefined) {\n      return cachedDimension;\n    }\n\n    var measuredDimension = getElementToMeasureDimension();\n\n    _measurementCache.addMeasurementToCache(measuredData, measuredDimension);\n\n    return measuredDimension;\n  }\n  /**\n   * Will get the next IResizeGroupState based on the current data while trying to shrink contents\n   * to fit in the container.\n   * @param data - The initial data point to start measuring.\n   * @param onReduceData - Function that transforms the data into something that should render with less width/height.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _shrinkContentsUntilTheyFit(data, onReduceData, getElementToMeasureDimension) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension > _containerDimension) {\n      var nextMeasuredData = onReduceData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onReduceData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData,\n          resizeDirection: 'shrink'\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    }\n\n    return {\n      renderedData: dataToMeasure,\n      resizeDirection: undefined,\n      dataToMeasure: undefined\n    };\n  }\n  /**\n   * This function should be called when the state changes in a manner that might allow for more content to fit\n   * on the screen, such as the window width/height growing.\n   * @param data - The initial data point to start measuring.\n   * @param onGrowData - Function that transforms the data into something that may take up more space when rendering.\n   * @param getElementToMeasureDimension - A function that returns the measurement of the rendered data.\n   * Only called when the measurement is not in the cache.\n   */\n\n\n  function _growDataUntilItDoesNotFit(data, onGrowData, getElementToMeasureDimension, onReduceData) {\n    var dataToMeasure = data;\n\n    var measuredDimension = _getMeasuredDimension(data, getElementToMeasureDimension);\n\n    while (measuredDimension < _containerDimension) {\n      var nextMeasuredData = onGrowData(dataToMeasure); // We don't want to get stuck in an infinite render loop when there are no more\n      // scaling steps, so implementations of onGrowData should return undefined when\n      // there are no more scaling states to apply.\n\n      if (nextMeasuredData === undefined) {\n        return {\n          renderedData: dataToMeasure,\n          resizeDirection: undefined,\n          dataToMeasure: undefined\n        };\n      }\n\n      measuredDimension = _measurementCache.getCachedMeasurement(nextMeasuredData); // If the measurement isn't in the cache, we need to rerender with some data in a hidden div\n\n      if (measuredDimension === undefined) {\n        return {\n          dataToMeasure: nextMeasuredData\n        };\n      }\n\n      dataToMeasure = nextMeasuredData;\n    } // Once the loop is done, we should now shrink until the contents fit.\n\n\n    return __assign({\n      resizeDirection: 'shrink'\n    }, _shrinkContentsUntilTheyFit(dataToMeasure, onReduceData, getElementToMeasureDimension));\n  }\n  /**\n   * Handles an update to the container width/height.\n   * Should only be called when we knew the previous container width/height.\n   * @param newDimension - The new width/height of the container.\n   * @param fullDimensionData - The initial data passed in as a prop to resizeGroup.\n   * @param renderedData - The data that was rendered prior to the container size changing.\n   * @param onGrowData - Set to true if the Resize group has an onGrowData function.\n   */\n\n\n  function _updateContainerDimension(newDimension, fullDimensionData, renderedData, onGrowData) {\n    var nextState;\n\n    if (newDimension > _containerDimension) {\n      if (onGrowData) {\n        nextState = {\n          resizeDirection: 'grow',\n          dataToMeasure: onGrowData(renderedData)\n        };\n      } else {\n        nextState = {\n          resizeDirection: 'shrink',\n          dataToMeasure: fullDimensionData\n        };\n      }\n    } else {\n      nextState = {\n        resizeDirection: 'shrink',\n        dataToMeasure: renderedData\n      };\n    }\n\n    _containerDimension = newDimension;\n    return __assign(__assign({}, nextState), {\n      measureContainer: false\n    });\n  }\n\n  function getNextState(props, currentState, getElementToMeasureDimension, newContainerDimension) {\n    // If there is no new container width/height or data to measure, there is no need for a new state update\n    if (newContainerDimension === undefined && currentState.dataToMeasure === undefined) {\n      return undefined;\n    }\n\n    if (newContainerDimension) {\n      // If we know the last container size and we rendered data at that width/height, we can do an optimized render\n      if (_containerDimension && currentState.renderedData && !currentState.dataToMeasure) {\n        return __assign(__assign({}, currentState), _updateContainerDimension(newContainerDimension, props.data, currentState.renderedData, props.onGrowData));\n      } // If we are just setting the container width/height for the first time, we can't do any optimizations\n\n\n      _containerDimension = newContainerDimension;\n    }\n\n    var nextState = __assign(__assign({}, currentState), {\n      measureContainer: false\n    });\n\n    if (currentState.dataToMeasure) {\n      if (currentState.resizeDirection === 'grow' && props.onGrowData) {\n        nextState = __assign(__assign({}, nextState), _growDataUntilItDoesNotFit(currentState.dataToMeasure, props.onGrowData, getElementToMeasureDimension, props.onReduceData));\n      } else {\n        nextState = __assign(__assign({}, nextState), _shrinkContentsUntilTheyFit(currentState.dataToMeasure, props.onReduceData, getElementToMeasureDimension));\n      }\n    }\n\n    return nextState;\n  }\n  /** Function that determines if we need to render content for measurement based on the measurement cache contents. */\n\n\n  function shouldRenderDataForMeasurement(dataToMeasure) {\n    if (!dataToMeasure || _measurementCache.getCachedMeasurement(dataToMeasure) !== undefined) {\n      return false;\n    }\n\n    return true;\n  }\n\n  function getInitialResizeGroupState(data) {\n    return {\n      dataToMeasure: __assign({}, data),\n      resizeDirection: 'grow',\n      measureContainer: true\n    };\n  }\n\n  return {\n    getNextState: getNextState,\n    shouldRenderDataForMeasurement: shouldRenderDataForMeasurement,\n    getInitialResizeGroupState: getInitialResizeGroupState\n  };\n}; // Provides a context property that (if true) tells any child components that\n// they are only being used for measurement purposes and will not be visible.\n\nexport var MeasuredContext = React.createContext({\n  isMeasured: false\n}); // Styles for the hidden div used for measurement\n\nvar hiddenDivStyles = {\n  position: 'fixed',\n  visibility: 'hidden'\n};\nvar hiddenParentStyles = {\n  position: 'relative'\n};\nvar COMPONENT_NAME = 'ResizeGroup';\n\nvar ResizeGroupBase =\n/** @class */\nfunction (_super) {\n  __extends(ResizeGroupBase, _super);\n\n  function ResizeGroupBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._nextResizeGroupStateProvider = getNextResizeGroupStateProvider(); // The root div which is the container inside of which we are trying to fit content.\n\n    _this._root = React.createRef(); // A div that can be used for the initial measurement so that we can avoid mounting a second instance\n    // of the component being measured for the initial render.\n\n    _this._initialHiddenDiv = React.createRef(); // A hidden div that is used for mounting a new instance of the component for measurement in a hidden\n    // div without unmounting the currently visible content.\n\n    _this._updateHiddenDiv = React.createRef(); // Tracks if any content has been rendered to the user. This enables us to do some performance optimizations\n    // for the initial render.\n\n    _this._hasRenderedContent = false;\n    _this.state = _this._nextResizeGroupStateProvider.getInitialResizeGroupState(_this.props.data);\n    initializeComponentRef(_this);\n    _this._async = new Async(_this);\n    _this._events = new EventGroup(_this);\n    warnDeprecations(COMPONENT_NAME, props, {\n      styles: 'className'\n    });\n    return _this;\n  }\n\n  ResizeGroupBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        onRenderData = _a.onRenderData;\n    var _b = this.state,\n        dataToMeasure = _b.dataToMeasure,\n        renderedData = _b.renderedData;\n    var divProps = getNativeProps(this.props, divProperties, ['data']);\n\n    var dataNeedsMeasuring = this._nextResizeGroupStateProvider.shouldRenderDataForMeasurement(dataToMeasure);\n\n    var isInitialMeasure = !this._hasRenderedContent && dataNeedsMeasuring; // We only ever render the final content to the user. All measurements are done in a hidden div.\n    // For the initial render, we want this to be as fast as possible, so we need to make sure that we only mount one\n    // version of the component for measurement and the final render. For renders that update what is on screen, we\n    // want to make sure that there are no jarring effects such as the screen flashing as we apply scaling steps for\n    // measurement. In the update case, we mount a second version of the component just for measurement purposes and\n    // leave the rendered content untouched until we know the next state to show to the user.\n\n    return React.createElement(\"div\", __assign({}, divProps, {\n      className: className,\n      ref: this._root\n    }), React.createElement(\"div\", {\n      style: hiddenParentStyles\n    }, dataNeedsMeasuring && !isInitialMeasure && React.createElement(\"div\", {\n      style: hiddenDivStyles,\n      ref: this._updateHiddenDiv\n    }, React.createElement(MeasuredContext.Provider, {\n      value: {\n        isMeasured: true\n      }\n    }, onRenderData(dataToMeasure))), React.createElement(\"div\", {\n      ref: this._initialHiddenDiv,\n      style: isInitialMeasure ? hiddenDivStyles : undefined,\n      \"data-automation-id\": \"visibleContent\"\n    }, isInitialMeasure ? onRenderData(dataToMeasure) : renderedData && onRenderData(renderedData))));\n  };\n\n  ResizeGroupBase.prototype.componentDidMount = function () {\n    this._afterComponentRendered(this.props.direction);\n\n    this._events.on(window, 'resize', this._async.debounce(this._onResize, RESIZE_DELAY, {\n      leading: true\n    }));\n  };\n\n  ResizeGroupBase.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {\n    this.setState({\n      dataToMeasure: __assign({}, nextProps.data),\n      resizeDirection: 'grow',\n      // Receiving new props means the parent might rerender and the root width/height might change\n      measureContainer: true\n    });\n  };\n\n  ResizeGroupBase.prototype.componentDidUpdate = function (prevProps) {\n    if (this.state.renderedData) {\n      this._hasRenderedContent = true;\n\n      if (this.props.dataDidRender) {\n        this.props.dataDidRender(this.state.renderedData);\n      }\n    }\n\n    this._afterComponentRendered(this.props.direction);\n  };\n\n  ResizeGroupBase.prototype.componentWillUnmount = function () {\n    this._async.dispose();\n\n    this._events.dispose();\n  };\n\n  ResizeGroupBase.prototype.remeasure = function () {\n    if (this._root.current) {\n      this.setState({\n        measureContainer: true\n      });\n    }\n  };\n\n  ResizeGroupBase.prototype._afterComponentRendered = function (direction) {\n    var _this = this;\n\n    this._async.requestAnimationFrame(function () {\n      var containerDimension = undefined;\n\n      if (_this.state.measureContainer && _this._root.current) {\n        var boundingRect = _this._root.current.getBoundingClientRect();\n\n        containerDimension = direction && direction === ResizeGroupDirection.vertical ? boundingRect.height : boundingRect.width;\n      }\n\n      var nextState = _this._nextResizeGroupStateProvider.getNextState(_this.props, _this.state, function () {\n        var refToMeasure = !_this._hasRenderedContent ? _this._initialHiddenDiv : _this._updateHiddenDiv;\n\n        if (!refToMeasure.current) {\n          return 0;\n        }\n\n        return direction && direction === ResizeGroupDirection.vertical ? refToMeasure.current.scrollHeight : refToMeasure.current.scrollWidth;\n      }, containerDimension);\n\n      if (nextState) {\n        _this.setState(nextState);\n      }\n    }, this._root.current);\n  };\n\n  ResizeGroupBase.prototype._onResize = function () {\n    if (this._root.current) {\n      this.setState({\n        measureContainer: true\n      });\n    }\n  };\n\n  return ResizeGroupBase;\n}(React.Component);\n\nexport { ResizeGroupBase };","map":null,"metadata":{},"sourceType":"module"}