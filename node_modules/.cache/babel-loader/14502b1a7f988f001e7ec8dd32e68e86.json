{"ast":null,"code":"import { EventGroup, getDocument } from '../../Utilities';\nvar MOUSEDOWN_PRIMARY_BUTTON = 0; // for mouse down event we are using ev.button property, 0 means left button\n\nvar MOUSEMOVE_PRIMARY_BUTTON = 1; // for mouse move event we are using ev.buttons property, 1 means left button\n\nvar DragDropHelper =\n/** @class */\nfunction () {\n  function DragDropHelper(params) {\n    this._selection = params.selection;\n    this._dragEnterCounts = {};\n    this._activeTargets = {};\n    this._lastId = 0; // To make this class cheap to create, which allows simplifying some logic elsewhere,\n    // only initialize the event group and global event handlers as needed.\n\n    this._initialized = false;\n  }\n\n  DragDropHelper.prototype.dispose = function () {\n    if (this._events) {\n      this._events.dispose();\n    }\n  };\n\n  DragDropHelper.prototype.subscribe = function (root, events, dragDropOptions) {\n    var _this = this;\n\n    if (!this._initialized) {\n      this._events = new EventGroup(this);\n      var doc = getDocument(); // clear drag data when mouse up, use capture event to ensure it will be run\n\n      if (doc) {\n        this._events.on(doc.body, 'mouseup', this._onMouseUp.bind(this), true);\n\n        this._events.on(doc, 'mouseup', this._onDocumentMouseUp.bind(this), true);\n      }\n\n      this._initialized = true;\n    }\n\n    var _a = dragDropOptions.key,\n        key = _a === void 0 ? \"\" + ++this._lastId : _a;\n    var handlers = [];\n    var onDragStart;\n    var onDragLeave;\n    var onDragEnter;\n    var onDragEnd;\n    var onDrop;\n    var onDragOver;\n    var onMouseDown;\n    var isDraggable;\n    var isDroppable;\n    var activeTarget;\n\n    if (dragDropOptions && root) {\n      var eventMap = dragDropOptions.eventMap,\n          context = dragDropOptions.context,\n          updateDropState_1 = dragDropOptions.updateDropState;\n      var dragDropTarget = {\n        root: root,\n        options: dragDropOptions,\n        key: key\n      };\n      isDraggable = this._isDraggable(dragDropTarget);\n      isDroppable = this._isDroppable(dragDropTarget);\n\n      if (isDraggable || isDroppable) {\n        if (eventMap) {\n          for (var _i = 0, eventMap_1 = eventMap; _i < eventMap_1.length; _i++) {\n            var event_1 = eventMap_1[_i];\n            var handler = {\n              callback: event_1.callback.bind(null, context),\n              eventName: event_1.eventName\n            };\n            handlers.push(handler);\n\n            this._events.on(root, handler.eventName, handler.callback);\n          }\n        }\n      }\n\n      if (isDroppable) {\n        // If the target is droppable, wire up global event listeners to track drop-related events.\n        onDragLeave = function onDragLeave(event) {\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]--;\n\n            if (_this._dragEnterCounts[key] === 0) {\n              updateDropState_1(false\n              /* isDropping */\n              , event);\n            }\n          }\n        };\n\n        onDragEnter = function onDragEnter(event) {\n          event.preventDefault(); // needed for IE\n\n          if (!event.isHandled) {\n            event.isHandled = true;\n            _this._dragEnterCounts[key]++;\n\n            if (_this._dragEnterCounts[key] === 1) {\n              updateDropState_1(true\n              /* isDropping */\n              , event);\n            }\n          }\n        };\n\n        onDragEnd = function onDragEnd(event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false\n          /* isDropping */\n          , event);\n        };\n\n        onDrop = function onDrop(event) {\n          _this._dragEnterCounts[key] = 0;\n          updateDropState_1(false\n          /* isDropping */\n          , event);\n\n          if (dragDropOptions.onDrop) {\n            dragDropOptions.onDrop(dragDropOptions.context.data, event);\n          }\n        };\n\n        onDragOver = function onDragOver(event) {\n          event.preventDefault();\n\n          if (dragDropOptions.onDragOver) {\n            dragDropOptions.onDragOver(dragDropOptions.context.data, event);\n          }\n        };\n\n        this._dragEnterCounts[key] = 0; // dragenter and dragleave will be fired when hover to the child element\n        // but we only want to change state when enter or leave the current element\n        // use the count to ensure it.\n\n        events.on(root, 'dragenter', onDragEnter);\n        events.on(root, 'dragleave', onDragLeave);\n        events.on(root, 'dragend', onDragEnd);\n        events.on(root, 'drop', onDrop);\n        events.on(root, 'dragover', onDragOver);\n      }\n\n      if (isDraggable) {\n        // If the target is draggable, wire up local event listeners for mouse events.\n        onMouseDown = this._onMouseDown.bind(this, dragDropTarget);\n        onDragEnd = this._onDragEnd.bind(this, dragDropTarget); // We need to add in data so that on Firefox we show the ghost element when dragging\n\n        onDragStart = function onDragStart(event) {\n          var options = dragDropOptions;\n\n          if (options && options.onDragStart) {\n            options.onDragStart(options.context.data, options.context.index, _this._selection.getSelection(), event);\n          }\n\n          _this._isDragging = true;\n\n          if (event.dataTransfer) {\n            event.dataTransfer.setData('id', root.id);\n          }\n        };\n\n        events.on(root, 'dragstart', onDragStart);\n        events.on(root, 'mousedown', onMouseDown);\n        events.on(root, 'dragend', onDragEnd);\n      }\n\n      activeTarget = {\n        target: dragDropTarget,\n        dispose: function dispose() {\n          if (_this._activeTargets[key] === activeTarget) {\n            delete _this._activeTargets[key];\n          }\n\n          if (root) {\n            for (var _i = 0, handlers_1 = handlers; _i < handlers_1.length; _i++) {\n              var handler = handlers_1[_i];\n\n              _this._events.off(root, handler.eventName, handler.callback);\n            }\n\n            if (isDroppable) {\n              events.off(root, 'dragenter', onDragEnter);\n              events.off(root, 'dragleave', onDragLeave);\n              events.off(root, 'dragend', onDragEnd);\n              events.off(root, 'dragover', onDragOver);\n              events.off(root, 'drop', onDrop);\n            }\n\n            if (isDraggable) {\n              events.off(root, 'dragstart', onDragStart);\n              events.off(root, 'mousedown', onMouseDown);\n              events.off(root, 'dragend', onDragEnd);\n            }\n          }\n        }\n      };\n      this._activeTargets[key] = activeTarget;\n    }\n\n    return {\n      key: key,\n      dispose: function dispose() {\n        if (activeTarget) {\n          activeTarget.dispose();\n        }\n      }\n    };\n  };\n\n  DragDropHelper.prototype.unsubscribe = function (root, key) {\n    var activeTarget = this._activeTargets[key];\n\n    if (activeTarget) {\n      activeTarget.dispose();\n    }\n  };\n\n  DragDropHelper.prototype._onDragEnd = function (target, event) {\n    var options = target.options;\n\n    if (options.onDragEnd) {\n      options.onDragEnd(options.context.data, event);\n    }\n  };\n  /**\n   * clear drag data when mouse up on body\n   */\n\n\n  DragDropHelper.prototype._onMouseUp = function (event) {\n    this._isDragging = false;\n\n    if (this._dragData) {\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.off(activeTarget.target.root, 'mousemove');\n\n          this._events.off(activeTarget.target.root, 'mouseleave');\n        }\n      }\n\n      if (this._dragData.dropTarget) {\n        // raise dragleave event to let dropTarget know it need to remove dropping style\n        EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n        EventGroup.raise(this._dragData.dropTarget.root, 'drop');\n      }\n    }\n\n    this._dragData = null;\n  };\n  /**\n   * clear drag data when mouse up outside of the document\n   */\n\n\n  DragDropHelper.prototype._onDocumentMouseUp = function (event) {\n    var doc = getDocument();\n\n    if (doc && event.target === doc.documentElement) {\n      this._onMouseUp(event);\n    }\n  };\n  /**\n   * when mouse move over a new drop target while dragging some items,\n   * fire dragleave on the old target and fire dragenter to the new target\n   * The target will handle style change on dragenter and dragleave events.\n   */\n\n\n  DragDropHelper.prototype._onMouseMove = function (target, event) {\n    var // use buttons property here since ev.button in some edge case is not updating well during the move.\n    // but firefox doesn't support it, so we set the default value when it is not defined.\n    _a = event.buttons,\n        // use buttons property here since ev.button in some edge case is not updating well during the move.\n    // but firefox doesn't support it, so we set the default value when it is not defined.\n    buttons = _a === void 0 ? MOUSEMOVE_PRIMARY_BUTTON : _a;\n\n    if (this._dragData && buttons !== MOUSEMOVE_PRIMARY_BUTTON) {\n      // cancel mouse down event and return early when the primary button is not pressed\n      this._onMouseUp(event);\n\n      return;\n    }\n\n    var root = target.root,\n        key = target.key;\n\n    if (this._isDragging) {\n      if (this._isDroppable(target)) {\n        // we can have nested drop targets in the DOM, like a folder inside a group. In that case, when we drag into\n        // the inner target (folder), we first set dropTarget to the inner element. But the same event is bubbled to the\n        // outer target too, and we need to prevent the outer one from taking over.\n        // So, check if the last dropTarget is not a child of the current.\n        if (this._dragData) {\n          if (this._dragData.dropTarget && this._dragData.dropTarget.key !== key && !this._isChild(root, this._dragData.dropTarget.root)) {\n            if (this._dragEnterCounts[this._dragData.dropTarget.key] > 0) {\n              EventGroup.raise(this._dragData.dropTarget.root, 'dragleave');\n              EventGroup.raise(root, 'dragenter');\n              this._dragData.dropTarget = target;\n            }\n          }\n        }\n      }\n    }\n  };\n  /**\n   * when mouse leave a target while dragging some items, fire dragleave to the target\n   */\n\n\n  DragDropHelper.prototype._onMouseLeave = function (target, event) {\n    if (this._isDragging) {\n      if (this._dragData && this._dragData.dropTarget && this._dragData.dropTarget.key === target.key) {\n        EventGroup.raise(target.root, 'dragleave');\n        this._dragData.dropTarget = undefined;\n      }\n    }\n  };\n  /**\n   * when mouse down on a draggable item, we start to track dragdata.\n   */\n\n\n  DragDropHelper.prototype._onMouseDown = function (target, event) {\n    if (event.button !== MOUSEDOWN_PRIMARY_BUTTON) {\n      // Ignore anything except the primary button.\n      return;\n    }\n\n    if (this._isDraggable(target)) {\n      this._dragData = {\n        clientX: event.clientX,\n        clientY: event.clientY,\n        eventTarget: event.target,\n        dragTarget: target\n      };\n\n      for (var _i = 0, _a = Object.keys(this._activeTargets); _i < _a.length; _i++) {\n        var key = _a[_i];\n        var activeTarget = this._activeTargets[key];\n\n        if (activeTarget.target.root) {\n          this._events.on(activeTarget.target.root, 'mousemove', this._onMouseMove.bind(this, activeTarget.target));\n\n          this._events.on(activeTarget.target.root, 'mouseleave', this._onMouseLeave.bind(this, activeTarget.target));\n        }\n      }\n    } else {\n      this._dragData = null;\n    }\n  };\n  /**\n   * determine whether the child target is a descendant of the parent\n   */\n\n\n  DragDropHelper.prototype._isChild = function (parentElement, childElement) {\n    while (childElement && childElement.parentElement) {\n      if (childElement.parentElement === parentElement) {\n        return true;\n      }\n\n      childElement = childElement.parentElement;\n    }\n\n    return false;\n  };\n\n  DragDropHelper.prototype._isDraggable = function (target) {\n    var options = target.options;\n    return !!(options.canDrag && options.canDrag(options.context.data));\n  };\n\n  DragDropHelper.prototype._isDroppable = function (target) {\n    // TODO: take the drag item into consideration to prevent dragging an item into the same group\n    var options = target.options;\n    var dragContext = this._dragData && this._dragData.dragTarget ? this._dragData.dragTarget.options.context : undefined;\n    return !!(options.canDrop && options.canDrop(options.context, dragContext));\n  };\n\n  return DragDropHelper;\n}();\n\nexport { DragDropHelper };","map":null,"metadata":{},"sourceType":"module"}