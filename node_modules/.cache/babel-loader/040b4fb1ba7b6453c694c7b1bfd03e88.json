{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { KeyCodes, css, initializeComponentRef } from '../../Utilities';\nimport { Autofill } from '../../Autofill';\nimport * as stylesImport from './BaseExtendedPicker.scss';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nimport { Selection, SelectionMode, SelectionZone } from '../../Selection';\nvar styles = stylesImport;\n\nvar BaseExtendedPicker =\n/** @class */\nfunction (_super) {\n  __extends(BaseExtendedPicker, _super);\n\n  function BaseExtendedPicker(basePickerProps) {\n    var _this = _super.call(this, basePickerProps) || this;\n\n    _this.floatingPicker = React.createRef();\n    _this.selectedItemsList = React.createRef();\n    _this.root = React.createRef();\n    _this.input = React.createRef();\n\n    _this.onSelectionChange = function () {\n      _this.forceUpdate();\n    };\n\n    _this.onInputChange = function (value, composing) {\n      // We don't want to update the picker's suggestions when the input is still being composed\n      if (!composing) {\n        _this.setState({\n          queryString: value\n        });\n\n        if (_this.floatingPicker.current) {\n          _this.floatingPicker.current.onQueryStringChanged(value);\n        }\n      }\n    };\n\n    _this.onInputFocus = function (ev) {\n      if (_this.selectedItemsList.current) {\n        _this.selectedItemsList.current.unselectAll();\n      }\n\n      if (_this.props.inputProps && _this.props.inputProps.onFocus) {\n        _this.props.inputProps.onFocus(ev);\n      }\n    };\n\n    _this.onInputClick = function (ev) {\n      if (_this.selectedItemsList.current) {\n        _this.selectedItemsList.current.unselectAll();\n      }\n\n      if (_this.floatingPicker.current && _this.inputElement) {\n        // Update the value if the input value is empty or is different than the current inputText from the floatingPicker\n        var shoudUpdateValue = _this.inputElement.value === '' || _this.inputElement.value !== _this.floatingPicker.current.inputText;\n\n        _this.floatingPicker.current.showPicker(shoudUpdateValue);\n      }\n    }; // This is protected because we may expect the backspace key to work differently in a different kind of picker.\n    // This lets the subclass override it and provide it's own onBackspace. For an example see the BasePickerListBelow\n\n\n    _this.onBackspace = function (ev) {\n      if (ev.which !== KeyCodes.backspace) {\n        return;\n      }\n\n      if (_this.selectedItemsList.current && _this.items.length) {\n        if (_this.input.current && !_this.input.current.isValueSelected && _this.input.current.inputElement === document.activeElement && _this.input.current.cursorLocation === 0) {\n          if (_this.floatingPicker.current) {\n            _this.floatingPicker.current.hidePicker();\n          }\n\n          ev.preventDefault();\n\n          _this.selectedItemsList.current.removeItemAt(_this.items.length - 1);\n\n          _this._onSelectedItemsChanged();\n        } else if (_this.selectedItemsList.current.hasSelectedItems()) {\n          if (_this.floatingPicker.current) {\n            _this.floatingPicker.current.hidePicker();\n          }\n\n          ev.preventDefault();\n\n          _this.selectedItemsList.current.removeSelectedItems();\n\n          _this._onSelectedItemsChanged();\n        }\n      }\n    };\n\n    _this.onCopy = function (ev) {\n      if (_this.selectedItemsList.current) {\n        // Pass it down into the selected items list\n        _this.selectedItemsList.current.onCopy(ev);\n      }\n    };\n\n    _this.onPaste = function (ev) {\n      if (_this.props.onPaste) {\n        var inputText = ev.clipboardData.getData('Text');\n        ev.preventDefault();\n\n        _this.props.onPaste(inputText);\n      }\n    };\n\n    _this._onSuggestionSelected = function (item) {\n      var currentRenderedQueryString = _this.props.currentRenderedQueryString;\n      var queryString = _this.state.queryString;\n\n      if (currentRenderedQueryString === undefined || currentRenderedQueryString === queryString) {\n        var processedItem = _this.props.onItemSelected ? _this.props.onItemSelected(item) : item;\n\n        if (processedItem === null) {\n          return;\n        }\n\n        var processedItemObject = processedItem;\n        var processedItemPromiseLike = processedItem;\n        var newItem_1;\n\n        if (processedItemPromiseLike && processedItemPromiseLike.then) {\n          processedItemPromiseLike.then(function (resolvedProcessedItem) {\n            newItem_1 = resolvedProcessedItem;\n\n            _this._addProcessedItem(newItem_1);\n          });\n        } else {\n          newItem_1 = processedItemObject;\n\n          _this._addProcessedItem(newItem_1);\n        }\n      }\n    };\n\n    _this._onSelectedItemsChanged = function () {\n      _this.focus();\n    };\n    /**\n     * The floating picker is the source of truth for if the menu has been opened or not.\n     *\n     * Because this isn't tracked inside the state of this component, we need to\n     * force an update here to keep the rendered output that depends on the picker being open\n     * in sync with the state\n     *\n     * Called when the suggestions is shown or closed\n     */\n\n\n    _this._onSuggestionsShownOrHidden = function () {\n      _this.forceUpdate();\n    };\n\n    initializeComponentRef(_this);\n    _this.selection = new Selection({\n      onSelectionChanged: function onSelectionChanged() {\n        return _this.onSelectionChange();\n      }\n    });\n    _this.state = {\n      queryString: '',\n      // TODO: determine whether this can be removed\n      // eslint-disable-next-line react/no-unused-state\n      suggestionItems: _this.props.suggestionItems ? _this.props.suggestionItems : null,\n      selectedItems: _this.props.defaultSelectedItems ? _this.props.defaultSelectedItems : _this.props.selectedItems ? _this.props.selectedItems : null\n    };\n    _this.floatingPickerProps = _this.props.floatingPickerProps;\n    _this.selectedItemsListProps = _this.props.selectedItemsListProps;\n    return _this;\n  }\n\n  Object.defineProperty(BaseExtendedPicker.prototype, \"items\", {\n    get: function get() {\n      var _a, _b, _c;\n\n      return _c = (_a = this.state.selectedItems, _a !== null && _a !== void 0 ? _a : (_b = this.selectedItemsList.current) === null || _b === void 0 ? void 0 : _b.items), _c !== null && _c !== void 0 ? _c : null;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseExtendedPicker.prototype.componentDidMount = function () {\n    this.forceUpdate();\n  };\n\n  BaseExtendedPicker.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {\n    if (newProps.floatingPickerProps) {\n      this.floatingPickerProps = newProps.floatingPickerProps;\n    }\n\n    if (newProps.selectedItemsListProps) {\n      this.selectedItemsListProps = newProps.selectedItemsListProps;\n    }\n\n    if (newProps.selectedItems) {\n      this.setState({\n        selectedItems: newProps.selectedItems\n      });\n    }\n  };\n\n  BaseExtendedPicker.prototype.focus = function () {\n    if (this.input.current) {\n      this.input.current.focus();\n    }\n  };\n\n  BaseExtendedPicker.prototype.clearInput = function () {\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n  };\n\n  Object.defineProperty(BaseExtendedPicker.prototype, \"inputElement\", {\n    get: function get() {\n      return this.input.current && this.input.current.inputElement;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(BaseExtendedPicker.prototype, \"highlightedItems\", {\n    get: function get() {\n      return this.selectedItemsList.current ? this.selectedItemsList.current.highlightedItems() : [];\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  BaseExtendedPicker.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        inputProps = _a.inputProps,\n        disabled = _a.disabled,\n        focusZoneProps = _a.focusZoneProps;\n    var activeDescendant = this.floatingPicker.current && this.floatingPicker.current.currentSelectedSuggestionIndex !== -1 ? 'sug-' + this.floatingPicker.current.currentSelectedSuggestionIndex : undefined;\n    var isExpanded = this.floatingPicker.current ? this.floatingPicker.current.isSuggestionsShown : false;\n    return React.createElement(\"div\", {\n      ref: this.root,\n      className: css('ms-BasePicker ms-BaseExtendedPicker', className ? className : ''),\n      onKeyDown: this.onBackspace,\n      onCopy: this.onCopy\n    }, React.createElement(FocusZone, __assign({\n      direction: FocusZoneDirection.bidirectional\n    }, focusZoneProps), React.createElement(SelectionZone, {\n      selection: this.selection,\n      selectionMode: SelectionMode.multiple\n    }, React.createElement(\"div\", {\n      className: css('ms-BasePicker-text', styles.pickerText),\n      role: 'list'\n    }, this.props.headerComponent, this.renderSelectedItemsList(), this.canAddItems() && React.createElement(Autofill, __assign({}, inputProps, {\n      className: css('ms-BasePicker-input', styles.pickerInput),\n      ref: this.input,\n      onFocus: this.onInputFocus,\n      onClick: this.onInputClick,\n      onInputValueChange: this.onInputChange,\n      \"aria-activedescendant\": activeDescendant,\n      \"aria-owns\": isExpanded ? 'suggestion-list' : undefined,\n      \"aria-expanded\": isExpanded,\n      \"aria-haspopup\": \"true\",\n      role: \"combobox\",\n      disabled: disabled,\n      onPaste: this.onPaste\n    }))))), this.renderFloatingPicker());\n  };\n\n  BaseExtendedPicker.prototype.canAddItems = function () {\n    var itemLimit = this.props.itemLimit;\n    return itemLimit === undefined || this.items.length < itemLimit;\n  };\n\n  BaseExtendedPicker.prototype.renderFloatingPicker = function () {\n    var FloatingPicker = this.props.onRenderFloatingPicker;\n    return React.createElement(FloatingPicker, __assign({\n      componentRef: this.floatingPicker,\n      onChange: this._onSuggestionSelected,\n      onSuggestionsHidden: this._onSuggestionsShownOrHidden,\n      onSuggestionsShown: this._onSuggestionsShownOrHidden,\n      inputElement: this.input.current ? this.input.current.inputElement : undefined,\n      selectedItems: this.items,\n      suggestionItems: this.props.suggestionItems ? this.props.suggestionItems : undefined\n    }, this.floatingPickerProps));\n  };\n\n  BaseExtendedPicker.prototype.renderSelectedItemsList = function () {\n    var SelectedItems = this.props.onRenderSelectedItems;\n    return React.createElement(SelectedItems, __assign({\n      componentRef: this.selectedItemsList,\n      selection: this.selection,\n      selectedItems: this.props.selectedItems ? this.props.selectedItems : undefined,\n      onItemsDeleted: this.props.selectedItems ? this.props.onItemsRemoved : undefined\n    }, this.selectedItemsListProps));\n  };\n\n  BaseExtendedPicker.prototype._addProcessedItem = function (newItem) {\n    // If this is a controlled component, call the on item selected callback\n    // Otherwise add it to the selectedItemsList\n    if (this.props.onItemAdded) {\n      this.props.onItemAdded(newItem);\n    }\n\n    if (this.selectedItemsList.current) {\n      this.selectedItemsList.current.addItems([newItem]);\n    }\n\n    if (this.input.current) {\n      this.input.current.clear();\n    }\n\n    if (this.floatingPicker.current) {\n      this.floatingPicker.current.hidePicker();\n    }\n\n    this.focus();\n  };\n\n  return BaseExtendedPicker;\n}(React.Component);\n\nexport { BaseExtendedPicker };","map":null,"metadata":{},"sourceType":"module"}