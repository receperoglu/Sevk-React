{"ast":null,"code":"import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { initializeComponentRef, classNamesFunction, KeyCodes, getRTLSafeKeyCode, css } from '../../Utilities';\nimport { GroupedListSection } from './GroupedListSection';\nimport { List } from '../../List';\nimport { SelectionMode } from '../../utilities/selection/index';\nimport { DEFAULT_ROW_HEIGHTS } from '../DetailsList/DetailsRow.styles';\nimport { FocusZone, FocusZoneDirection } from '../../FocusZone';\nvar getClassNames = classNamesFunction();\nvar ROW_HEIGHT = DEFAULT_ROW_HEIGHTS.rowHeight,\n    COMPACT_ROW_HEIGHT = DEFAULT_ROW_HEIGHTS.compactRowHeight;\n\nvar GroupedListBase =\n/** @class */\nfunction (_super) {\n  __extends(GroupedListBase, _super);\n\n  function GroupedListBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this._list = React.createRef();\n\n    _this._renderGroup = function (group, groupIndex) {\n      var _a = _this.props,\n          dragDropEvents = _a.dragDropEvents,\n          dragDropHelper = _a.dragDropHelper,\n          eventsToRegister = _a.eventsToRegister,\n          groupProps = _a.groupProps,\n          items = _a.items,\n          listProps = _a.listProps,\n          onRenderCell = _a.onRenderCell,\n          selectionMode = _a.selectionMode,\n          selection = _a.selection,\n          viewport = _a.viewport,\n          onShouldVirtualize = _a.onShouldVirtualize,\n          groups = _a.groups,\n          compact = _a.compact; // override group header/footer props as needed\n\n      var dividerProps = {\n        onToggleSelectGroup: _this._onToggleSelectGroup,\n        onToggleCollapse: _this._onToggleCollapse,\n        onToggleSummarize: _this._onToggleSummarize\n      };\n\n      var headerProps = __assign(__assign({}, groupProps.headerProps), dividerProps);\n\n      var showAllProps = __assign(__assign({}, groupProps.showAllProps), dividerProps);\n\n      var footerProps = __assign(__assign({}, groupProps.footerProps), dividerProps);\n\n      var groupNestingDepth = _this._getGroupNestingDepth();\n\n      if (!groupProps.showEmptyGroups && group && group.count === 0) {\n        return null;\n      }\n\n      var finalListProps = __assign(__assign({}, listProps || {}), {\n        version: _this.state.version\n      });\n\n      return React.createElement(GroupedListSection, {\n        key: _this._getGroupKey(group, groupIndex),\n        dragDropEvents: dragDropEvents,\n        dragDropHelper: dragDropHelper,\n        eventsToRegister: eventsToRegister,\n        footerProps: footerProps,\n        getGroupItemLimit: groupProps && groupProps.getGroupItemLimit,\n        group: group,\n        groupIndex: groupIndex,\n        groupNestingDepth: groupNestingDepth,\n        groupProps: groupProps,\n        headerProps: headerProps,\n        listProps: finalListProps,\n        items: items,\n        onRenderCell: onRenderCell,\n        onRenderGroupHeader: groupProps.onRenderHeader,\n        onRenderGroupShowAll: groupProps.onRenderShowAll,\n        onRenderGroupFooter: groupProps.onRenderFooter,\n        selectionMode: selectionMode,\n        selection: selection,\n        showAllProps: showAllProps,\n        viewport: viewport,\n        onShouldVirtualize: onShouldVirtualize,\n        groupedListClassNames: _this._classNames,\n        groups: groups,\n        compact: compact\n      });\n    };\n\n    _this._getDefaultGroupItemLimit = function (group) {\n      return group.count;\n    };\n\n    _this._getGroupItemLimit = function (group) {\n      var groupProps = _this.props.groupProps;\n      var getGroupItemLimit = groupProps && groupProps.getGroupItemLimit ? groupProps.getGroupItemLimit : _this._getDefaultGroupItemLimit;\n      return getGroupItemLimit(group);\n    };\n\n    _this._getGroupHeight = function (group) {\n      var rowHeight = _this.props.compact ? COMPACT_ROW_HEIGHT : ROW_HEIGHT;\n      return rowHeight + (group.isCollapsed ? 0 : rowHeight * _this._getGroupItemLimit(group));\n    };\n\n    _this._getPageHeight = function (itemIndex) {\n      var groups = _this.state.groups;\n      var _a = _this.props.getGroupHeight,\n          getGroupHeight = _a === void 0 ? _this._getGroupHeight : _a;\n      var pageGroup = groups && groups[itemIndex];\n\n      if (pageGroup) {\n        return getGroupHeight(pageGroup, itemIndex);\n      } else {\n        return 0;\n      }\n    };\n\n    _this._onToggleCollapse = function (group) {\n      var groupProps = _this.props.groupProps;\n      var onToggleCollapse = groupProps && groupProps.headerProps && groupProps.headerProps.onToggleCollapse;\n\n      if (group) {\n        if (onToggleCollapse) {\n          onToggleCollapse(group);\n        }\n\n        group.isCollapsed = !group.isCollapsed;\n\n        _this._updateIsSomeGroupExpanded();\n\n        _this.forceUpdate();\n      }\n    };\n\n    _this._onToggleSelectGroup = function (group) {\n      var _a = _this.props,\n          selection = _a.selection,\n          selectionMode = _a.selectionMode;\n\n      if (group && selection && selectionMode === SelectionMode.multiple) {\n        selection.toggleRangeSelected(group.startIndex, group.count);\n      }\n    };\n\n    _this._isInnerZoneKeystroke = function (ev) {\n      return ev.which === getRTLSafeKeyCode(KeyCodes.right);\n    };\n\n    _this._onToggleSummarize = function (group) {\n      var groupProps = _this.props.groupProps;\n      var onToggleSummarize = groupProps && groupProps.showAllProps && groupProps.showAllProps.onToggleSummarize;\n\n      if (onToggleSummarize) {\n        onToggleSummarize(group);\n      } else {\n        if (group) {\n          group.isShowingAll = !group.isShowingAll;\n        }\n\n        _this.forceUpdate();\n      }\n    };\n\n    _this._getPageSpecification = function (itemIndex) {\n      var groups = _this.state.groups;\n      var pageGroup = groups && groups[itemIndex];\n      return {\n        key: pageGroup && pageGroup.key\n      };\n    };\n\n    initializeComponentRef(_this);\n    _this._isSomeGroupExpanded = _this._computeIsSomeGroupExpanded(props.groups);\n    var _a = props.listProps,\n        _b = (_a === void 0 ? {} : _a).version,\n        version = _b === void 0 ? {} : _b;\n    _this.state = {\n      groups: props.groups,\n      items: props.items,\n      listProps: props.listProps,\n      version: version\n    };\n    return _this;\n  }\n\n  GroupedListBase.getDerivedStateFromProps = function (nextProps, previousState) {\n    var groups = nextProps.groups,\n        selectionMode = nextProps.selectionMode,\n        compact = nextProps.compact,\n        items = nextProps.items,\n        listProps = nextProps.listProps;\n    var listVersion = listProps && listProps.version;\n\n    var nextState = __assign(__assign({}, previousState), {\n      selectionMode: selectionMode,\n      compact: compact,\n      groups: groups,\n      listProps: listProps\n    });\n\n    var shouldForceUpdates = false;\n    var previousListVersion = previousState.listProps && previousState.listProps.version;\n\n    if (listVersion !== previousListVersion || items !== previousState.items || groups !== previousState.groups || selectionMode !== previousState.selectionMode || compact !== previousState.compact) {\n      // If there are any props not passed explicitly to `List` which have an impact on the behavior of `onRenderCell`,\n      // these need to 'force-update' this component by revving the version. Otherwise, the List might render with stale\n      // data.\n      shouldForceUpdates = true;\n    }\n\n    if (shouldForceUpdates) {\n      nextState = __assign(__assign({}, nextState), {\n        version: {}\n      });\n    }\n\n    return nextState;\n  };\n\n  GroupedListBase.prototype.scrollToIndex = function (index, measureItem, scrollToMode) {\n    if (this._list.current) {\n      this._list.current.scrollToIndex(index, measureItem, scrollToMode);\n    }\n  };\n\n  GroupedListBase.prototype.getStartItemIndexInView = function () {\n    return this._list.current.getStartItemIndexInView() || 0;\n  };\n\n  GroupedListBase.prototype.componentDidMount = function () {\n    var _a = this.props,\n        groupProps = _a.groupProps,\n        _b = _a.groups,\n        groups = _b === void 0 ? [] : _b;\n\n    if (groupProps && groupProps.isAllGroupsCollapsed) {\n      this._setGroupsCollapsedState(groups, groupProps.isAllGroupsCollapsed);\n    }\n  };\n\n  GroupedListBase.prototype.render = function () {\n    var _a = this.props,\n        className = _a.className,\n        usePageCache = _a.usePageCache,\n        onShouldVirtualize = _a.onShouldVirtualize,\n        theme = _a.theme,\n        _b = _a.role,\n        role = _b === void 0 ? 'treegrid' : _b,\n        styles = _a.styles,\n        compact = _a.compact,\n        _c = _a.focusZoneProps,\n        focusZoneProps = _c === void 0 ? {} : _c,\n        _d = _a.rootListProps,\n        rootListProps = _d === void 0 ? {} : _d;\n    var _e = this.state,\n        groups = _e.groups,\n        version = _e.version;\n    this._classNames = getClassNames(styles, {\n      theme: theme,\n      className: className,\n      compact: compact\n    });\n    var _f = focusZoneProps.shouldEnterInnerZone,\n        shouldEnterInnerZone = _f === void 0 ? this._isInnerZoneKeystroke : _f;\n    return React.createElement(FocusZone, __assign({\n      direction: FocusZoneDirection.vertical,\n      \"data-automationid\": \"GroupedList\",\n      \"data-is-scrollable\": \"false\",\n      role: \"presentation\"\n    }, focusZoneProps, {\n      shouldEnterInnerZone: shouldEnterInnerZone,\n      className: css(this._classNames.root, focusZoneProps.className)\n    }), !groups ? this._renderGroup(undefined, 0) : React.createElement(List, __assign({\n      ref: this._list,\n      role: role,\n      items: groups,\n      onRenderCell: this._renderGroup,\n      getItemCountForPage: this._returnOne,\n      getPageHeight: this._getPageHeight,\n      getPageSpecification: this._getPageSpecification,\n      usePageCache: usePageCache,\n      onShouldVirtualize: onShouldVirtualize,\n      version: version\n    }, rootListProps)));\n  };\n\n  GroupedListBase.prototype.forceUpdate = function () {\n    _super.prototype.forceUpdate.call(this);\n\n    this._forceListUpdates();\n  };\n\n  GroupedListBase.prototype.toggleCollapseAll = function (allCollapsed) {\n    var _a = this.state.groups,\n        groups = _a === void 0 ? [] : _a;\n    var groupProps = this.props.groupProps;\n    var onToggleCollapseAll = groupProps && groupProps.onToggleCollapseAll;\n\n    if (groups.length > 0) {\n      if (onToggleCollapseAll) {\n        onToggleCollapseAll(allCollapsed);\n      }\n\n      this._setGroupsCollapsedState(groups, allCollapsed);\n\n      this._updateIsSomeGroupExpanded();\n\n      this.forceUpdate();\n    }\n  };\n\n  GroupedListBase.prototype._setGroupsCollapsedState = function (groups, isCollapsed) {\n    for (var groupIndex = 0; groupIndex < groups.length; groupIndex++) {\n      groups[groupIndex].isCollapsed = isCollapsed;\n    }\n  };\n\n  GroupedListBase.prototype._returnOne = function () {\n    return 1;\n  };\n\n  GroupedListBase.prototype._getGroupKey = function (group, index) {\n    return 'group-' + (group && group.key ? group.key : String(index));\n  };\n\n  GroupedListBase.prototype._getGroupNestingDepth = function () {\n    var groups = this.state.groups;\n    var level = 0;\n    var groupsInLevel = groups;\n\n    while (groupsInLevel && groupsInLevel.length > 0) {\n      level++;\n      groupsInLevel = groupsInLevel[0].children;\n    }\n\n    return level;\n  };\n\n  GroupedListBase.prototype._forceListUpdates = function (groups) {\n    this.setState({\n      version: {}\n    });\n  };\n\n  GroupedListBase.prototype._computeIsSomeGroupExpanded = function (groups) {\n    var _this = this;\n\n    return !!(groups && groups.some(function (group) {\n      return group.children ? _this._computeIsSomeGroupExpanded(group.children) : !group.isCollapsed;\n    }));\n  };\n\n  GroupedListBase.prototype._updateIsSomeGroupExpanded = function () {\n    var groups = this.state.groups;\n    var onGroupExpandStateChanged = this.props.onGroupExpandStateChanged;\n\n    var newIsSomeGroupExpanded = this._computeIsSomeGroupExpanded(groups);\n\n    if (this._isSomeGroupExpanded !== newIsSomeGroupExpanded) {\n      if (onGroupExpandStateChanged) {\n        onGroupExpandStateChanged(newIsSomeGroupExpanded);\n      }\n\n      this._isSomeGroupExpanded = newIsSomeGroupExpanded;\n    }\n  };\n\n  GroupedListBase.defaultProps = {\n    selectionMode: SelectionMode.multiple,\n    isHeaderVisible: true,\n    groupProps: {},\n    compact: false\n  };\n  return GroupedListBase;\n}(React.Component);\n\nexport { GroupedListBase };","map":null,"metadata":{},"sourceType":"module"}